///////////////////////////////////////////////////////////////////////////////
// Name:        nsall.idl
// Purpose:     wxwebconnect: embedded web browser control library
// Author:      Benjamin I. Williams, Peter Fritz
// Modified by:
// Created:     2006-10-08
// RCS-ID:      
// Copyright:   (C) Copyright 2006-2010, Kirix Corporation, All Rights Reserved.
// Licence:     wxWindows Library Licence, Version 3.1
///////////////////////////////////////////////////////////////////////////////


// To generate an .h file from this .idl file, run the following command
//    xpidl -m header nsall.idl


///////////////////////////////////////////////////////////////////////////////
//  nsrootidl
///////////////////////////////////////////////////////////////////////////////


%{C++
#if 0
%}

typedef unsigned long nsresult;
typedef unsigned long nsrefcnt;
typedef unsigned long PRUint32;
typedef long PRInt32;
typedef long long PRInt64;
typedef unsigned long long PRTime;
//FIXME it needs for jsid
//typedef unsigned long size_t;
//typedef struct jsid { size_t asBits; };

[ref, utf8string] native AUTF8String(ignored);

[ref, astring] native AString(ignored);
[ref, cstring] native ACString(ignored);
[ref, domstring] native DOMString(ignored);

[nsid] native nsIID(nsIID);
[ref, nsid] native nsIIDRef(nsIID);
[ptr] native nsQIResult(void);
[nsid] native nsCID(nsCID);
[ref, nsid] native nsCIDRef(nsCID);
[ptr, nsid] native nsCIDPtr(nsCID);

[ptr] native voidPtr(void);
[ref] native voidPtrRef(void*);
[ptr] native charPtr(char);
[ref] native PRBoolRef(PRBool);

[ref, jsval]  native jsval(jsval);
              native jsid(jsid);

%{C++
#endif
%}




///////////////////////////////////////////////////////////////////////////////
//  nsISupports
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(00000000-0000-0000-c000-000000000046)]
interface nsISupports
{
    void QueryInterface(in nsIIDRef iid,
                        [iid_is(iid), retval] out nsQIResult result);
    [noscript, notxpcom] nsrefcnt AddRef();
    [noscript, notxpcom] nsrefcnt Release();
};




///////////////////////////////////////////////////////////////////////////////
//  nsISimpleEnumerator
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(d1899240-f9d2-11d2-bdd6-000064657374)]
interface nsISimpleEnumerator : nsISupports
{
    boolean hasMoreElements();
    nsISupports getNext();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIFactory
///////////////////////////////////////////////////////////////////////////////


[scriptable, object, uuid(00000001-0000-0000-c000-000000000046)]
interface nsIFactory : nsISupports
{
    void createInstance(in nsISupports outer,
                        in nsIIDRef iid,
                        [iid_is(iid),retval] out nsQIResult result);
                        
    void lockFactory(in boolean lock);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIInterfaceRequestor
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(033a1470-8b2a-11d3-af88-00a024ffc08c)]
interface nsIInterfaceRequestor : nsISupports
{
    void getInterface(in nsIIDRef iid,
                      [iid_is(iid), retval] out nsQIResult result);
                      
/*
    This error is already present on http://developer.mozilla.org/xpcom/api/.
    On http://www.xulplanet.com the function reads:
    void getInterface (nsIIDRef uuid, out nsQIResult* result)
*/
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWeakReference
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(9188bc85-f92e-11d2-81ef-0060083a0bcf)]
interface nsIWeakReference : nsISupports
{
    void QueryReferent(in nsIIDRef iid,
                       [iid_is(iid), retval] out nsQIResult result);
};

[scriptable, uuid(9188bc86-f92e-11d2-81ef-0060083a0bcf)]
interface nsISupportsWeakReference : nsISupports
{
    nsIWeakReference GetWeakReference();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIFile
///////////////////////////////////////////////////////////////////////////////


interface nsISimpleEnumerator;

[scriptable, uuid(c8c0a080-0868-11d3-915f-d9d889d48e3c)]
interface nsIFile : nsISupports
{
    const unsigned long NORMAL_FILE_TYPE = 0;
    const unsigned long DIRECTORY_TYPE   = 1;
    
    void append(in AString node);
    [noscript] void appendNative(in ACString node);
    void normalize();
    void create(in PRUint32 type, in PRUint32 permissions);

    attribute AString leafName;
    [noscript] attribute ACString nativeLeafName;

    void copyTo(in nsIFile parent_dir, in AString name);
    [noscript] void copyToNative(in nsIFile parent_dir, in ACString name);
    void copyToFollowingLinks(in nsIFile parent_dir, in AString name);
    [noscript] void copyToFollowingLinksNative(in nsIFile parent_dir,
                                               in ACString name);
    void moveTo(in nsIFile parent_dir, in AString name);
    [noscript] void moveToNative(in nsIFile parent_dir, in ACString name);
    void remove(in boolean recursive);
    
    attribute unsigned long permissions;
    attribute unsigned long permissionsOfLink;
    attribute PRInt64 lastModifiedTime;
    attribute PRInt64 lastModifiedTimeOfLink;
    attribute PRInt64 fileSize;
    readonly attribute PRInt64 fileSizeOfLink;
    
    readonly attribute AString target;
    [noscript] readonly attribute ACString nativeTarget;
    
    readonly attribute AString path;
    [noscript] readonly attribute ACString nativePath;
    
    boolean exists();
    boolean isWritable();
    boolean isReadable();
    boolean isExecutable();
    boolean isHidden();
    boolean isDirectory();
    boolean isFile();
    boolean isSymlink();
    boolean isSpecial();
    void createUnique(in PRUint32 type, in PRUint32 permissions);
    nsIFile clone();
    boolean equals(in nsIFile file);
    boolean contains(in nsIFile file, in boolean recurse);
    
    readonly attribute nsIFile parent;
    readonly attribute nsISimpleEnumerator directoryEntries;
};




///////////////////////////////////////////////////////////////////////////////
//  nsILocalFile
///////////////////////////////////////////////////////////////////////////////


%{C++
struct PRFileDesc;
struct PRLibrary;
%}

[ptr] native PRFileDescStar(PRFileDesc);
[ptr] native PRLibraryStar(PRLibrary);
[ptr] native FILEStar(FILE);


[scriptable, uuid(aa610f20-a889-11d3-8c81-000064657374)]
interface nsILocalFile : nsIFile
{
    void initWithPath(in AString file_path);
    [noscript] void initWithNativePath(in ACString file_path);
    void initWithFile(in nsILocalFile file);
    
    attribute boolean followLinks;

    [noscript] PRFileDescStar openNSPRFileDesc(in long flags, in long mode);
    [noscript] FILEStar openANSIFileDesc(in string mode);
    [noscript] PRLibraryStar load();
    void appendRelativePath(in AString rel_path);
    [noscript] void appendRelativeNativePath(in ACString rel_path);
    
    attribute ACString persistentDescriptor;
    
    void reveal();
    void launch();
    
    ACString getRelativeDescriptor(in nsILocalFile from_file);
    void setRelativeDescriptor(in nsILocalFile from_file, in ACString rel_desc);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIAppShell
///////////////////////////////////////////////////////////////////////////////


interface nsIEventQueue;
native int(int);

[scriptable, function, uuid(4a2abaf0-6886-11d3-9382-00104ba0fd40)]
interface nsIRunnable : nsISupports
{
    void run();
};


[uuid(40bc6280-ad83-471e-b197-80ab90e2065e)]
interface nsIAppShell : nsISupports
{
    void favorPerformanceHint(in boolean favorPerfOverStarvation,
                            in unsigned long starvationDelay);
    void suspendNative();
    void resumeNative();
    readonly attribute unsigned long eventloopNestingLevel;
    void runInStableState(in nsIRunnable aRunnable);
    void run();
    void exit();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIBadCertListener
///////////////////////////////////////////////////////////////////////////////


interface nsIInterfaceRequestor;
interface nsIInterfaceRequestor;


[scriptable, uuid(f0980f60-ee3d-11d4-998b-00b0d02354a0)]
interface nsIX509Cert : nsISupports
{
    // to be filled out later
};

interface nsIX509Cert;

[scriptable, uuid(cfede939-def1-49be-81ed-d401b3a07d1c)]
interface nsISSLStatus : nsISupports
{
    readonly attribute nsIX509Cert serverCert;
    readonly attribute string cipherName;
    readonly attribute unsigned long keyLength;
    readonly attribute unsigned long secretKeyLength;
    readonly attribute boolean isDomainMismatch;
    readonly attribute boolean isNotValidAtThisTime;
    readonly attribute boolean isUntrusted;
};


/*
[scriptable, object, uuid(86960956-edb0-11d4-998b-00b0d02354a0)]
interface nsIBadCertListener : nsISupports
{
    const short UNINIT_ADD_FLAG = -1;
    const short ADD_TRUSTED_FOR_SESSION = 1;
    const short ADD_TRUSTED_PERMANENTLY = 2;

    boolean confirmUnknownIssuer(in nsIInterfaceRequestor socketInfo, in nsIX509Cert cert, out short certAddType);
    boolean confirmMismatchDomain(in nsIInterfaceRequestor socketInfo, in AUTF8String targetURL, in nsIX509Cert cert);
    boolean confirmCertExpired(in nsIInterfaceRequestor socketInfo, in nsIX509Cert cert);
    void notifyCrlNextupdate(in nsIInterfaceRequestor socketInfo, in AUTF8String targetURL, in nsIX509Cert cert);
};
*/


[scriptable, uuid(2c3d268c-ad82-49f3-99aa-e9ffddd7a0dc)]
interface nsIBadCertListener2 : nsISupports
{
    boolean notifyCertProblem(in nsIInterfaceRequestor socket_info, 
                              in nsISSLStatus status,
                              in AUTF8String target_site);
};


[scriptable, uuid(a5ae8b05-a76e-408f-b0ba-02a831265749)]
interface nsIRecentBadCertsService : nsISupports
{
    nsISSLStatus getRecentBadCert(in AString host_name_with_port);
    
    void addBadCert(in AString host_name_with_port,
                    in nsISSLStatus status);
};



[scriptable, uuid(31738d2a-77d3-4359-84c9-4be2f38fb8c5)]
interface nsICertOverrideService : nsISupports
{
    const short ERROR_UNTRUSTED = 1;
    const short ERROR_MISMATCH = 2;
    const short ERROR_TIME = 4;

    void rememberValidityOverride(
                            in ACString host_name, 
                            in PRInt32 port,
                            in nsIX509Cert cert,
                            in PRUint32 override_bits,
                            in boolean temporary);

    boolean hasMatchingOverride(
                            in ACString host_name, 
                            in PRInt32 port,
                            in nsIX509Cert cert,
                            out PRUint32 override_bits,
                            out boolean is_temporary);

    boolean getValidityOverride(
                            in ACString host_name, 
                            in PRInt32 port,
                            out ACString hash_alg,
                            out ACString fingerprint,
                            out PRUint32 override_bits,
                            out boolean is_temporary);

    void clearValidityOverride(
                            in ACString host_name,
                            in PRInt32 port);

    void getAllOverrideHostsWithPorts(
                            out PRUint32 count, 
                            [array, size_is(count)] out wstring hosts_with_ports_array);

    PRUint32 isCertUsedForOverrides(
                            in nsIX509Cert cert,
                            in boolean check_temporaries,
                            in boolean check_permanents);
};



///////////////////////////////////////////////////////////////////////////////
//  nsIBaseWindow
///////////////////////////////////////////////////////////////////////////////


typedef voidPtr nativeWindow;
[ptr] native nsIWidget(nsIWidget);

%{ C++
    class nsIWidget;
%}

[scriptable, uuid(046bc8a0-8015-11d3-af70-00a024ffc08c)]
interface nsIBaseWindow : nsISupports
{
    [noscript] void initWindow(in nativeWindow parentNativeWindow,
                               in nsIWidget parentWidget,
                               in long x,
                               in long y,
                               in long cx,
                               in long cy);
    void create();
    void destroy();
    
    void setPosition(in long x, in long y);
    void getPosition(out long x, out long y);
    
    void setSize(in long cx, in long cy, in boolean repaint);
    void getSize(out long cx, out long cy);

    void setPositionAndSize(in long x,
                            in long y,
                            in long cx,
                            in long cy,
                            in boolean repaint);

    void getPositionAndSize(out long x,
                            out long y,
                            out long cx,
                            out long cy);

    void repaint(in boolean force);

    [noscript] attribute nsIWidget parentWidget;
    attribute nativeWindow parentNativeWindow;
    attribute boolean visibility;
    attribute boolean enabled;
    attribute boolean blurSuppression;
    [noscript] readonly attribute nsIWidget mainWidget;

    void setFocus();

    attribute wstring title;
};




///////////////////////////////////////////////////////////////////////////////
//  nsICacheService
///////////////////////////////////////////////////////////////////////////////


typedef long nsCacheStoragePolicy;
interface nsISimpleEnumerator;
interface nsICacheListener;
interface nsICacheSession;
interface nsICacheVisitor;
interface nsIEventTarget;

[scriptable, uuid(14dbe1e9-f3bc-45af-92f4-2c574fcd4e39)]
interface nsICacheService : nsISupports
{
    nsICacheSession createSession(in string clientID,
                        in nsCacheStoragePolicy storagePolicy,
                        in boolean streamBased);
    void visitEntries(in nsICacheVisitor visitor);
    void evictEntries(in nsCacheStoragePolicy storagePolicy);
    readonly attribute nsIEventTarget cacheIOTarget;
};




///////////////////////////////////////////////////////////////////////////////
//  nsICancelable
///////////////////////////////////////////////////////////////////////////////


[scriptable, object, uuid(d94ac0a0-bb18-46b8-844e-84159064b0bd)]
interface nsICancelable : nsISupports
{
    void cancel(in nsresult reason);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIRequest
///////////////////////////////////////////////////////////////////////////////


interface nsILoadGroup;
typedef unsigned long nsLoadFlags;


[scriptable, uuid(ef6bfbd2-fd46-48d8-96b7-9f8f0fd387fe)]
interface nsIRequest : nsISupports
{
    const unsigned long LOAD_NORMAL = 0;
    const unsigned long LOAD_BACKGROUND = 1;
    const unsigned long INHIBIT_CACHING = 128;
    const unsigned long INHIBIT_PERSISTENT_CACHING = 256;
    const unsigned long LOAD_BYPASS_CACHE = 512;
    const unsigned long LOAD_FROM_CACHE = 1024;
    const unsigned long VALIDATE_ALWAYS = 2048;
    const unsigned long VALIDATE_NEVER = 4096;
    const unsigned long VALIDATE_ONCE_PER_SESSION = 8192;

    readonly attribute AUTF8String name;
    
    boolean isPending();
    
    readonly attribute nsresult status;
    
    void cancel(in nsresult status);
    void suspend();
    void resume();
    
    attribute nsILoadGroup loadGroup;
    attribute nsLoadFlags loadFlags;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIURI
///////////////////////////////////////////////////////////////////////////////

%{C++
#undef GetPort  // XXX Windows!
#undef SetPort  // XXX Windows!
%}

[scriptable, uuid(07a22cc0-0ce5-11d3-9331-00104ba0fd40)]
interface nsIURI : nsISupports
{
    attribute AUTF8String spec;
    readonly attribute AUTF8String prePath;
    attribute ACString scheme;
    attribute AUTF8String userPass;
    attribute AUTF8String username;
    attribute AUTF8String password;
    attribute AUTF8String hostPort;
    attribute AUTF8String host;
    attribute long port;
    attribute AUTF8String path;

    boolean equals(in nsIURI other);
    boolean schemeIs(in string scheme);
    nsIURI clone();
    AUTF8String resolve(in AUTF8String relative_path);
    
    readonly attribute ACString asciiSpec;
    readonly attribute ACString asciiHost;
    readonly attribute ACString originCharset;
};


///////////////////////////////////////////////////////////////////////////////
//  nsIURIFixup
///////////////////////////////////////////////////////////////////////////////

interface nsIURI;
[scriptable, uuid(773081ac-9f81-4bdb-9e7a-5e87b4361f09)]
interface nsIURIFixup : nsISupports
{
    const unsigned long FIXUP_FLAG_NONE = 0;
    const unsigned long FIXUP_FLAG_ALLOW_KEYWORD_LOOKUP = 1;
    const unsigned long FIXUP_FLAGS_MAKE_ALTERNATE_URI = 2;

    nsIURI createExposableURI(in nsIURI uri);
    nsIURI createFixupURI(in AUTF8String aURIText, in unsigned long fixup_flags);
    nsIURI keywordToURI(in AUTF8String keyword);
};



///////////////////////////////////////////////////////////////////////////////
//  nsIChannel
///////////////////////////////////////////////////////////////////////////////

interface nsIURI;
interface nsIInterfaceRequestor;
interface nsIInputStream;
interface nsIStreamListener;

[scriptable, uuid(c63a055a-a676-4e71-bf3c-6cfa11082018)]
interface nsIChannel : nsIRequest
{
    const unsigned long LOAD_DOCUMENT_URI = 65536;
    const unsigned long LOAD_RETARGETED_DOCUMENT_URI = 131072;
    const unsigned long LOAD_REPLACE = 262144;
    const unsigned long LOAD_INITIAL_DOCUMENT_URI = 524288;
    const unsigned long LOAD_TARGETED = 1048576;

    attribute nsIURI originalURI;
    readonly attribute nsIURI URI;
    attribute nsISupports owner;
    attribute nsIInterfaceRequestor notificationCallbacks;
    readonly attribute nsISupports securityInfo;
    attribute ACString contentType;
    attribute ACString contentCharset;
    attribute long contentLength;


    nsIInputStream open();
    void asyncOpen(in nsIStreamListener listener, in nsISupports xcontext);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIClipboardCommands
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(b8100c90-73be-11d2-92a5-00105a1b0d64)]
interface nsIClipboardCommands : nsISupports
{
    boolean canCutSelection();
    boolean canCopySelection();
    boolean canCopyLinkLocation();
    boolean canCopyImageLocation();
    boolean canCopyImageContents();
    boolean canPaste();
    void cutSelection();
    void copySelection();
    void copyLinkLocation();
    void copyImageLocation();
    void copyImageContents();
    void paste();
    void selectAll();
    void selectNone();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIComponentManager
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(a88e5a60-205a-4bb1-94e1-2628daf51eae)]
interface nsIComponentManager : nsISupports
{
    void getClassObject(in nsCIDRef class_id,
                        in nsIIDRef iid,
                        [iid_is(iid),retval] out nsQIResult result);
                        
    void getClassObjectByContractID(
                        in string contract_id,
                        in nsIIDRef iid,
                        [iid_is(iid),retval] out nsQIResult result);
                                  
    void createInstance(in nsCIDRef class_id,
                        in nsISupports delegate,
                        in nsIIDRef iid,
                        [iid_is(iid),retval] out nsQIResult result);
                        
    void createInstanceByContractID(
                        in string contract_id,
                        in nsISupports delegate,
                        in nsIIDRef iid,
                        [iid_is(iid),retval] out nsQIResult result);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIComponentRegistrar
///////////////////////////////////////////////////////////////////////////////


interface nsIFactory;
interface nsISimpleEnumerator;

[scriptable, uuid(2417cbfe-65ad-48a6-b4b6-eb84db174392)]
interface nsIComponentRegistrar : nsISupports
{
    void autoRegister(in nsIFile spec);
    void autoUnregister(in nsIFile spec);
    
    void registerFactory(in nsCIDRef class_id,
                         in string class_name,
                         in string contract_id,
                         in nsIFactory factory);
                         
    void unregisterFactory(
                         in nsCIDRef class_id,
                         in nsIFactory factory);
                         
    void registerFactoryLocation(
                         in nsCIDRef class_id,
                         in string class_name,
                         in string contract_id,
                         in nsIFile file,
                         in string loader_str,
                         in string type);
                         
    void unregisterFactoryLocation(
                         in nsCIDRef class_id,
                         in nsIFile file);
                         
    boolean isCIDRegistered(in nsCIDRef class_id);
    boolean isContractIDRegistered(in string contract_id);
    nsISimpleEnumerator enumerateCIDs();
    nsISimpleEnumerator enumerateContractIDs();
    string CIDToContractID(in nsCIDRef class_id);
    nsCIDPtr contractIDToCID(in string contract_id);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIContextMenuListener2
///////////////////////////////////////////////////////////////////////////////


interface nsIContextMenuInfo;
interface nsIDOMEvent;
interface nsIDOMNode;
interface imgIContainer;


[scriptable, uuid(7fb719b3-d804-4964-9596-77cf924ee314)]
interface nsIContextMenuListener2 : nsISupports
{
    void onShowContextMenu(in unsigned long context_flags,
                           in nsIContextMenuInfo utils);
};


 
[scriptable, uuid(2f977d56-5485-11d4-87e2-0010a4e75ef2)]
interface nsIContextMenuInfo : nsISupports
{
    readonly attribute nsIDOMEvent mouseEvent;
    readonly attribute nsIDOMNode targetNode;
    readonly attribute AString associatedLink;
    readonly attribute imgIContainer imageContainer;
    readonly attribute nsIURI imageSrc;
    readonly attribute imgIContainer backgroundImageContainer;
    readonly attribute nsIURI backgroundImageSrc;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDirectoryService
///////////////////////////////////////////////////////////////////////////////


interface nsISimpleEnumerator;


[scriptable, uuid(bbf8cab0-d43a-11d3-8cc2-00609792278c)]
interface nsIDirectoryServiceProvider : nsISupports
{
    nsIFile getFile(in string property, out boolean persistent);
};


[scriptable, uuid(2f977d4b-5485-11d4-87e2-0010a4e75ef2)]
interface nsIDirectoryServiceProvider2 : nsIDirectoryServiceProvider
{
    nsISimpleEnumerator getFiles(in string property);
};


[scriptable, uuid(57a66a60-d43a-11d3-8cc2-00609792278c)]
interface nsIDirectoryService : nsISupports
{
    void init();
    void registerProvider(in nsIDirectoryServiceProvider provider);
    void unregisterProvider(in nsIDirectoryServiceProvider provider);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDocShellTreeItem
///////////////////////////////////////////////////////////////////////////////


interface nsIDocShellTreeItem;


[scriptable, uuid(37f1ab73-f224-44b1-82f0-d2834ab1cec0)]
interface nsIDocShellTreeNode : nsISupports
{
    readonly attribute long childCount;
    void addChild(in nsIDocShellTreeItem child);
    void removeChild(in nsIDocShellTreeItem child);
    nsIDocShellTreeItem getChildAt(in long index);
    nsIDocShellTreeItem findChildWithName(in wstring name,
                                          in boolean recurse,
                                          in boolean same_type,
                                          in nsIDocShellTreeItem requestor,
                                          in nsIDocShellTreeItem original_requestor);
};


interface nsIDocShellTreeOwner;
[scriptable, uuid(09b54ec1-d98a-49a9-bc95-3219e8b55089)]
interface nsIDocShellTreeItem : nsIDocShellTreeNode
{
    attribute wstring name;

    boolean nameEquals(in wstring name);

    const long typeChrome = 0;
    const long typeContent = 1;
    const long typeContentWrapper = 2;
    const long typeChromeWrapper = 3;
    const long typeAll = 2147483647;

    attribute long itemType;

    readonly attribute nsIDocShellTreeItem parent;
    readonly attribute nsIDocShellTreeItem sameTypeParent;
    readonly attribute nsIDocShellTreeItem rootTreeItem;
    readonly attribute nsIDocShellTreeItem sameTypeRootTreeItem;

    nsIDocShellTreeItem findItemWithName(in wstring name,
                                         in nsISupports requestor,
                                         in nsIDocShellTreeItem original_requestor);
                                         
    readonly attribute nsIDocShellTreeOwner treeOwner;

    [noscript] void setTreeOwner(in nsIDocShellTreeOwner tree_owner);
};


[scriptable, uuid(7d935d63-6d2a-4600-afb5-9a4f7d68b825)]
interface ns18IDocShellTreeItem : nsISupports
{
    attribute wstring name;

    boolean nameEquals(in wstring name);

    const long typeChrome = 0;
    const long typeContent = 1;
    const long typeContentWrapper = 2;
    const long typeChromeWrapper = 3;
    const long typeAll = 2147483647;

    attribute long itemType;

    readonly attribute nsIDocShellTreeItem parent;
    readonly attribute nsIDocShellTreeItem sameTypeParent;
    readonly attribute nsIDocShellTreeItem rootTreeItem;
    readonly attribute nsIDocShellTreeItem sameTypeRootTreeItem;

    nsIDocShellTreeItem findItemWithName(in wstring name,
                                         in nsISupports requestor,
                                         in nsIDocShellTreeItem original_requestor);
                                         
    readonly attribute nsIDocShellTreeOwner treeOwner;

    [noscript] void setTreeOwner(in nsIDocShellTreeOwner tree_owner);

    attribute long childOffset;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOM3Node
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMNode;
interface DOMException;
interface nsIVariant;
interface nsIDOMUserDataHandler;

[scriptable, uuid(29fb2a18-1dd2-11b2-8dd9-a6fd5d5ad12f)]
interface nsIDOM3Node : nsISupports
{
    const unsigned short DOCUMENT_POSITION_DISCONNECTED = 0x01;
    const unsigned short DOCUMENT_POSITION_PRECEDING = 0x02;
    const unsigned short DOCUMENT_POSITION_FOLLOWING = 0x04;
    const unsigned short DOCUMENT_POSITION_CONTAINS = 0x08;
    const unsigned short DOCUMENT_POSITION_CONTAINED_BY = 0x10;
    const unsigned short DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
    
    readonly attribute DOMString       baseURI;

    unsigned short compareDocumentPosition(in nsIDOMNode other) raises(DOMException);

    attribute DOMString       textContent;

    boolean isSameNode(in nsIDOMNode other);
    DOMString lookupPrefix(in DOMString namespaceURI);
    boolean isDefaultNamespace(in DOMString namespaceURI);
    DOMString lookupNamespaceURI(in DOMString prefix);
    boolean isEqualNode(in nsIDOMNode arg);
    nsISupports getFeature(in DOMString feature, in DOMString version);
    nsIVariant setUserData(in DOMString key, in nsIVariant data, in nsIDOMUserDataHandler handler);
    nsIVariant getUserData(in DOMString key);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOM3Document
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMDOMConfiguration;

[scriptable, uuid(2e0e9ea1-72ab-4d9e-bdeb-ca64e1abeba4)]
interface nsIDOM3Document : nsIDOM3Node
{
    readonly attribute DOMString inputEncoding;
    readonly attribute DOMString xmlEncoding;
    attribute boolean xmlStandalone;
    attribute DOMString xmlVersion;
    attribute boolean strictErrorChecking;
    attribute DOMString documentURI;
    nsIDOMNode adoptNode(in nsIDOMNode source) raises(DOMException);
    readonly attribute nsIDOMDOMConfiguration domConfig;
    void normalizeDocument();
    nsIDOMNode renameNode(in nsIDOMNode node, in DOMString namespaceURI, in DOMString qualifiedName) raises(DOMException);
};


//typedef unsigned long long DOMTimeStamp;

// Core
interface nsIDOMAttr;
interface nsIDOMCDATASection;
interface nsIDOMCharacterData;
interface nsIDOMComment;
interface nsIDOMDOMImplementation;
interface nsIDOMDocument;
interface nsIDOMDocumentFragment;
interface nsIDOMDocumentType;
interface nsIDOMElement;
interface nsIDOMEntity;
interface nsIDOMEntityReference;
interface nsIDOMNSDocument;
interface nsIDOMNSElement;
interface nsIDOMNamedNodeMap;
interface nsIDOMNode;
interface nsIDOMNodeList;
interface nsIDOMNotation;
interface nsIDOMProcessingInstruction;
interface nsIDOMText;
interface nsIDOMDOMStringList;
interface nsIDOMDOMTokenList;
interface nsIDOMNameList;
interface nsIDOMClientRect;
interface nsIDOMClientRectList;

// Needed for raises() in our IDL
interface DOMException;
interface RangeException;
// Style Sheets
interface nsIDOMStyleSheetList;
interface nsIDOMLinkStyle;
interface nsIDOMStyleSheet;
interface nsIDOMMediaList;

// Views
interface nsIDOMAbstractView;
interface nsIDOMDocumentView;

// Base
interface nsIDOMWindow;
interface nsIDOMWindowInternal;
interface nsIDOMWindowCollection;
interface nsIDOMPlugin;
interface nsIDOMPluginArray;
interface nsIDOMMimeType;
interface nsIDOMMimeTypeArray;
interface nsIDOMBarProp;
interface nsIDOMNavigator;
interface nsIDOMScreen;
interface nsIDOMHistory;

// Events
interface nsIDOMEvent;
interface nsIDOMEventTarget;
interface nsIDOMEventListener;
interface nsIDOMEventGroup;

// HTML
interface nsIDOMHTMLElement;
interface nsIDOMHTMLFormElement;
interface nsIDOMHTMLCollection;
interface nsIDOMHTMLHeadElement;

// CSS
interface nsIDOMCSSValue;
interface nsIDOMCSSValueList;
interface nsIDOMCSSPrimitiveValue;
interface nsIDOMCSSRule;
interface nsIDOMCSSRuleList;
interface nsIDOMCSSStyleSheet;
interface nsIDOMCSSStyleDeclaration;
interface nsIDOMCounter;
interface nsIDOMRect;
interface nsIDOMRGBColor;
interface nsIDOMCSSStyleRule;
interface nsIDOMCSSStyleRuleCollection;
interface nsIDOMHTMLTableCaptionElement;
interface nsIDOMHTMLTableSectionElement;

// Range
interface nsIDOMRange;
// Crypto
interface nsIDOMCRMFObject;
interface nsIDOMCrypto;
interface nsIDOMPkcs11;

[scriptable, uuid(a6cf907c-15b3-11d2-932e-00805f8add32)]
interface nsIDOMNode : nsISupports
{
  const unsigned short      ELEMENT_NODE       = 1;
  const unsigned short      ATTRIBUTE_NODE     = 2;
  const unsigned short      TEXT_NODE          = 3;
  const unsigned short      CDATA_SECTION_NODE = 4;
  const unsigned short      ENTITY_REFERENCE_NODE = 5;
  const unsigned short      ENTITY_NODE        = 6;
  const unsigned short      PROCESSING_INSTRUCTION_NODE = 7;
  const unsigned short      COMMENT_NODE       = 8;
  const unsigned short      DOCUMENT_NODE      = 9;
  const unsigned short      DOCUMENT_TYPE_NODE = 10;
  const unsigned short      DOCUMENT_FRAGMENT_NODE = 11;
  const unsigned short      NOTATION_NODE      = 12;

  readonly attribute DOMString        nodeName;
           attribute DOMString        nodeValue;
                                          // raises(DOMException) on setting
                                          // raises(DOMException) on retrieval
  readonly attribute unsigned short   nodeType;
  readonly attribute nsIDOMNode       parentNode;
  readonly attribute nsIDOMNodeList   childNodes;
  readonly attribute nsIDOMNode       firstChild;
  readonly attribute nsIDOMNode       lastChild;
  readonly attribute nsIDOMNode       previousSibling;
  readonly attribute nsIDOMNode       nextSibling;
  readonly attribute nsIDOMNamedNodeMap attributes;
  // Modified in DOM Level 2:
  readonly attribute nsIDOMDocument   ownerDocument;
  nsIDOMNode                insertBefore(in nsIDOMNode newChild,
                                         in nsIDOMNode refChild)
                                          raises(DOMException);
  nsIDOMNode                replaceChild(in nsIDOMNode newChild,
                                         in nsIDOMNode oldChild)
                                          raises(DOMException);
  nsIDOMNode                removeChild(in nsIDOMNode oldChild)
                                         raises(DOMException);
  nsIDOMNode                appendChild(in nsIDOMNode newChild)
                                         raises(DOMException);
  boolean                   hasChildNodes();
  nsIDOMNode                cloneNode(in boolean deep);
  // Modified in DOM Level 2:
  void                      normalize();
  // Introduced in DOM Level 2:
  boolean                   isSupported(in DOMString feature,
                                        in DOMString version);
  // Introduced in DOM Level 2:
  readonly attribute DOMString        namespaceURI;
  // Introduced in DOM Level 2:
           attribute DOMString        prefix;
                                         // raises(DOMException) on setting
  // Introduced in DOM Level 2:
  readonly attribute DOMString        localName;
  // Introduced in DOM Level 2:
  boolean            hasAttributes();
};



///////////////////////////////////////////////////////////////////////////////
//  nsIDOMAttr
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMElement;

[scriptable, uuid(a6cf9070-15b3-11d2-932e-00805f8add32)]
interface nsIDOMAttr : nsIDOMNode
{
    readonly attribute DOMString name;
    readonly attribute boolean specified;
    attribute DOMString value;
    readonly attribute nsIDOMElement ownerElement;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMElement
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMAttr;
interface DOMException;


[scriptable, uuid(a6cf9078-15b3-11d2-932e-00805f8add32)]
interface nsIDOMElement : nsIDOMNode
{
    readonly attribute DOMString tagName;

    DOMString getAttribute(in DOMString name);

    void setAttribute(in DOMString name,
                      in DOMString value) raises(DOMException);

    void removeAttribute(in DOMString name) raises(DOMException);

    nsIDOMAttr getAttributeNode(in DOMString name);
    nsIDOMAttr setAttributeNode(in nsIDOMAttr new_attr) raises(DOMException);

    nsIDOMAttr removeAttributeNode(in nsIDOMAttr old_attr) raises(DOMException);
 
    nsIDOMNodeList getElementsByTagName(in DOMString name);

    DOMString getAttributeNS(in DOMString namespace_uri,
                             in DOMString local_name);

    void setAttributeNS(in DOMString namespace_uri,
                        in DOMString qualified_name,
                        in DOMString value) raises(DOMException);
      
    void removeAttributeNS(in DOMString namespace_uri,
                           in DOMString local_name) raises(DOMException);

    nsIDOMAttr getAttributeNodeNS(in DOMString namespace_uri,
                                  in DOMString local_name);
         
    nsIDOMAttr setAttributeNodeNS(in nsIDOMAttr newAttr) raises(DOMException);
    
    nsIDOMNodeList getElementsByTagNameNS(in DOMString namespace_uri,
                                          in DOMString local_name);
               
    boolean hasAttribute(in DOMString name);

    boolean hasAttributeNS(in DOMString namespace_uri,
                           in DOMString local_name);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMCharacterData
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(a6cf9072-15b3-11d2-932e-00805f8add32)]
interface nsIDOMCharacterData : nsIDOMNode
{
    attribute DOMString data;
    readonly attribute unsigned long length;
    
    DOMString substringData(in unsigned long offset,
                            in unsigned long count)
                            raises(DOMException);
                            
    void appendData(in DOMString arg)
                    raises(DOMException);
                    
    void insertData(in unsigned long offset,
                    in DOMString arg)
                    raises(DOMException);
                    
    void deleteData(in unsigned long offset,
                    in unsigned long count)
                    raises(DOMException);
                    
    void replaceData(in unsigned long offset,
                     in unsigned long count,
                     in DOMString arg)
                     raises(DOMException);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMDocument
///////////////////////////////////////////////////////////////////////////////



[scriptable, uuid(a6cf9075-15b3-11d2-932e-00805f8add32)]
interface nsIDOMDocument : nsIDOMNode
{
    readonly attribute nsIDOMDocumentType doctype;
    readonly attribute nsIDOMDOMImplementation implementation;
    readonly attribute nsIDOMElement documentElement;
  
    nsIDOMElement createElement(in DOMString tagName) raises(DOMException);
    nsIDOMDocumentFragment createDocumentFragment();
    nsIDOMText createTextNode(in DOMString data);
    nsIDOMComment createComment(in DOMString data);
    nsIDOMCDATASection createCDATASection(in DOMString data) raises(DOMException);
    nsIDOMProcessingInstruction createProcessingInstruction(in DOMString target, in DOMString data) raises(DOMException);
    nsIDOMAttr createAttribute(in DOMString name) raises(DOMException);
    nsIDOMEntityReference createEntityReference(in DOMString name) raises(DOMException);
    nsIDOMNodeList getElementsByTagName(in DOMString tagname);
    nsIDOMNode importNode(in nsIDOMNode importedNode, in boolean deep) raises(DOMException);
    nsIDOMElement createElementNS(in DOMString namespaceURI, in DOMString qualifiedName) raises(DOMException);
    nsIDOMAttr createAttributeNS(in DOMString namespaceURI, in DOMString qualifiedName) raises(DOMException);
    nsIDOMNodeList getElementsByTagNameNS(in DOMString namespaceURI, in DOMString localName);
    nsIDOMElement getElementById(in DOMString elementId);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMEvent
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMAbstractView;
interface nsIDOMEventTarget;
interface DOMTimeStamp;


[scriptable, uuid(a66b7b80-ff46-bd97-0080-5f8ae38add32)]
interface nsIDOMEvent : nsISupports
{
    const unsigned short CAPTURING_PHASE = 1;
    const unsigned short AT_TARGET = 2;
    const unsigned short BUBBLING_PHASE = 3;

    readonly attribute DOMString type;
    readonly attribute nsIDOMEventTarget target;
    readonly attribute nsIDOMEventTarget currentTarget;
    readonly attribute unsigned short eventPhase;
    readonly attribute boolean bubbles;
    readonly attribute boolean cancelable;
    readonly attribute DOMTimeStamp timeStamp;

    void stopPropagation();
    
    void preventDefault();
    
    void initEvent(in DOMString event_type_arg,
                   in boolean can_bubble_arg,
                   in boolean cancelable_arg);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMEventListener
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMEvent;


[scriptable, function, uuid(df31c120-ded6-11d1-bd85-00805f8ae3f4)]
interface nsIDOMEventListener : nsISupports
{
    void handleEvent(in nsIDOMEvent event);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMEventTarget
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMEvent;
interface nsIDOMEventListener;
interface DOMException;


[scriptable, uuid(1c773b30-d1cf-11d2-bd95-00805f8ae3f4)]
interface nsIDOMEventTarget : nsISupports
{
    void addEventListener(in DOMString type,
                          in nsIDOMEventListener listener,
                          in boolean use_capture);
                          
    void removeEventListener(
                          in DOMString type,
                          in nsIDOMEventListener listener,
                          in boolean use_capture);
                             
    boolean dispatchEvent(in nsIDOMEvent evt) raises(DOMException);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMHTMLElement
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(a6cf9085-15b3-11d2-932e-00805f8add32)]
interface nsIDOMHTMLElement : nsIDOMElement
{
    attribute DOMString id;
    attribute DOMString title;
    attribute DOMString lang;
    attribute DOMString dir;
    attribute DOMString className;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMHTMLAnchorElement
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(a6cf90aa-15b3-11d2-932e-00805f8add32)]
interface nsIDOMHTMLAnchorElement : nsIDOMHTMLElement
{
    attribute DOMString accessKey;
    attribute DOMString charset;
    attribute DOMString coords;
    attribute DOMString href;
    attribute DOMString hreflang;
    attribute DOMString name;
    attribute DOMString rel;
    attribute DOMString rev;
    attribute DOMString shape;
    attribute long tabIndex;
    attribute DOMString target;
    attribute DOMString type;

    void blur();
    void focus();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMHTMLInputElement
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMHTMLFormElement;


[scriptable, uuid(a6cf9095-15b3-11d2-932e-00805f8add32)]
interface nsIDOMHTMLButtonElement : nsIDOMHTMLElement
{
    readonly attribute nsIDOMHTMLFormElement form;
    attribute DOMString accessKey;
    attribute boolean disabled;
    attribute DOMString name;
    attribute long tabIndex;
    [noscript] readonly attribute DOMString type;
    attribute DOMString value;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMHTMLInputElement
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMHTMLFormElement;

[scriptable, uuid(a6cf9093-15b3-11d2-932e-00805f8add32)]
interface nsIDOMHTMLInputElement : nsIDOMHTMLElement
{
    attribute DOMString defaultValue;
    attribute boolean defaultChecked;
    readonly attribute nsIDOMHTMLFormElement form;
    attribute DOMString accept;
    attribute DOMString accessKey;
    attribute DOMString align;
    attribute DOMString alt;
    attribute boolean checked;
    attribute boolean disabled;
    attribute long maxLength;
    attribute DOMString name;
    attribute boolean readOnly;
    attribute unsigned long size;
    attribute DOMString src;
    attribute long tabIndex;
    attribute DOMString type;
    attribute DOMString useMap;
    attribute DOMString value;
    
    void blur();
    void focus();
    void select();
    void click();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMHTMLLinkElement
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(a6cf9088-15b3-11d2-932e-00805f8add32)]
interface nsIDOMHTMLLinkElement : nsIDOMHTMLElement
{
    attribute boolean disabled;
    attribute DOMString charset;
    attribute DOMString href;
    attribute DOMString hreflang;
    attribute DOMString media;
    attribute DOMString rel;
    attribute DOMString rev;
    attribute DOMString target;
    attribute DOMString type;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMHTMLInputElement
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMHTMLFormElement;


[scriptable, uuid(a6cf9092-15b3-11d2-932e-00805f8add32)]
interface nsIDOMHTMLOptionElement : nsIDOMHTMLElement
{
    readonly attribute nsIDOMHTMLFormElement form;
    attribute boolean defaultSelected;
    readonly attribute DOMString text;
    readonly attribute long index;
    attribute boolean disabled;
    attribute DOMString label;
    attribute boolean selected;
    attribute DOMString value;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMHTMLParamElement
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(a6cf90ad-15b3-11d2-932e-00805f8add32)]
interface nsIDOMHTMLParamElement : nsIDOMHTMLElement
{
    attribute DOMString name;
    attribute DOMString type;
    attribute DOMString value;
    attribute DOMString valueType;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMHTMLSelectElement
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMHTMLFormElement;
interface nsIDOMHTMLOptionsCollection;

[scriptable, uuid(a6cf9090-15b3-11d2-932e-00805f8add32)]
interface nsIDOMHTMLSelectElement : nsIDOMHTMLElement
{
    readonly attribute DOMString type;
    attribute long selectedIndex;
    attribute DOMString value;
    attribute unsigned long length;
    readonly attribute nsIDOMHTMLFormElement form;
    readonly attribute nsIDOMHTMLOptionsCollection options;
    attribute boolean disabled;
    attribute boolean multiple;
    attribute DOMString name;
    attribute long size;
    attribute long tabIndex;
    
    void add(in nsIDOMHTMLElement element,
             in nsIDOMHTMLElement before)
             raises(DOMException);
    
    void remove(in long index);
    void blur();
    void focus();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMHTMLTextAreaElement
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMHTMLFormElement;

[scriptable, uuid(a6cf9094-15b3-11d2-932e-00805f8add32)]
interface nsIDOMHTMLTextAreaElement : nsIDOMHTMLElement
{
    attribute DOMString defaultValue;
    readonly attribute nsIDOMHTMLFormElement form;
    attribute DOMString accessKey;
    attribute long cols;
    attribute boolean disabled;
    attribute DOMString name;
    attribute boolean readOnly;
    attribute long rows;
    attribute long tabIndex;
    readonly attribute DOMString type;
    attribute DOMString value;
    
    void blur();
    void focus();
    void select();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMUIEvent
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMAbstractView;

[scriptable, uuid(a6cf90c3-15b3-11d2-932e-00805f8add32)]
interface nsIDOMUIEvent : nsIDOMEvent
{
    readonly attribute nsIDOMAbstractView view;
    readonly attribute long detail;

    void initUIEvent(in DOMString type_arg,
                     in boolean can_bubble_arg,
                     in boolean cancelable_arg,
                     in nsIDOMAbstractView view_arg,
                     in long detail_arg);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMMouseEvent
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMAbstractView;
interface nsIDOMEventTarget;


[scriptable, uuid(ff751edc-8b02-aae7-0010-8301838a3123)]
interface nsIDOMMouseEvent : nsIDOMUIEvent
{
    readonly attribute long screenX;
    readonly attribute long screenY;
    readonly attribute long clientX;
    readonly attribute long clientY;
    readonly attribute boolean ctrlKey;
    readonly attribute boolean shiftKey;
    readonly attribute boolean altKey;
    readonly attribute boolean metaKey;
    readonly attribute unsigned short button;
    readonly attribute nsIDOMEventTarget relatedTarget;
  
    void initMouseEvent(in DOMString type_arg,
                        in boolean can_bubble_arg,
                        in boolean cancelable_arg,
                        in nsIDOMAbstractView view_arg,
                        in long detail_arg,
                        in long screen_x_arg,
                        in long screen_y_arg,
                        in long client_x_arg,
                        in long client_y_arg,
                        in boolean ctrl_key_arg,
                        in boolean alt_key_arg,
                        in boolean shift_key_arg,
                        in boolean meta_key_arg,
                        in unsigned short button_arg,
                        in nsIDOMEventTarget related_target_arg);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMNamedNodeMap
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMNode;
interface DOMException;


[scriptable, uuid(a6cf907b-15b3-11d2-932e-00805f8add32)]
interface nsIDOMNamedNodeMap : nsISupports
{
    nsIDOMNode getNamedItem(in DOMString name);
    nsIDOMNode setNamedItem(in nsIDOMNode arg) raises(DOMException);
    nsIDOMNode removeNamedItem(in DOMString name) raises(DOMException);
    nsIDOMNode item(in unsigned long index);
    
    readonly attribute unsigned long length;
    
    nsIDOMNode getNamedItemNS(in DOMString namespace_uri,
                              in DOMString local_name);
                                              
    nsIDOMNode setNamedItemNS(in nsIDOMNode arg)
                                      raises(DOMException);
    
    nsIDOMNode removeNamedItemNS(
                              in DOMString namespace_uri,
                              in DOMString local_name)
                                      raises(DOMException);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMNodeList
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMNode;

[scriptable, uuid(a6cf907d-15b3-11d2-932e-00805f8add32)]
interface nsIDOMNodeList : nsISupports
{
    nsIDOMNode item(in unsigned long index);
    readonly attribute unsigned long length;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMText
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(a6cf9082-15b3-11d2-932e-00805f8add32)]
interface nsIDOMText : nsIDOMCharacterData
{
    nsIDOMText splitText(in unsigned long offset)
                         raises(DOMException);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMWindow
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMDocument;
interface nsIDOMBarProp;
interface nsIDOMWindowCollection;
interface nsISelection;

[scriptable, uuid(a6cf906b-15b3-11d2-932e-00805f8add32)]
interface nsIDOMWindow : nsISupports
{
    readonly attribute nsIDOMDocument document;
    readonly attribute nsIDOMWindow parent;
    readonly attribute nsIDOMWindow top;
    readonly attribute nsIDOMBarProp scrollbars;
    [noscript] readonly attribute nsIDOMWindowCollection frames;
    attribute DOMString name;
    [noscript] attribute float textZoom;
    readonly attribute long scrollX;
    readonly attribute long scrollY;

    void scrollTo(in long x_scroll, in long y_scroll);
    void scrollBy(in long x_scroll_diff, in long y_scroll_diff);
    nsISelection getSelection();
    void scrollByLines(in long num_lines);
    void scrollByPages(in long num_pages);
    void sizeToContent();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIDOMWindow2
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMEventTarget;
interface nsIDOMOfflineResourceList;

[scriptable, uuid(65455132-b96a-40ec-adea-52fa22b1028c)]
interface ns18IDOMWindow2 : nsIDOMWindow
{
    [noscript] readonly attribute nsIDOMEventTarget windowRoot;
};


//[scriptable, uuid(73c5fa35-3add-4c87-a303-a850ccf4d65a)]
[scriptable, uuid(efff0d88-3b94-4375-bdeb-676a847ecd7d)]
interface nsIDOMWindow2 : nsIDOMWindow
{
    [noscript] readonly attribute nsIDOMEventTarget windowRoot;
    readonly attribute nsIDOMOfflineResourceList applicationCache;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIEmbeddingSiteWindow
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(3e5432cd-9568-4bd1-8cbe-d50aba110743)]
interface nsIEmbeddingSiteWindow : nsISupports
{
    const unsigned long DIM_FLAGS_POSITION = 1;
    const unsigned long DIM_FLAGS_SIZE_INNER = 2;
    const unsigned long DIM_FLAGS_SIZE_OUTER = 4;
    
    void setDimensions(in unsigned long flags,
                       in long x,
                       in long y,
                       in long cx,
                       in long cy);
                       
    void getDimensions(in unsigned long flags,
                       out long x,
                       out long y,
                       out long cx,
                       out long cy);
                       
    void setFocus();
    
    attribute boolean visibility;
    attribute wstring title;
    [noscript] readonly attribute voidPtr siteWindow;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIEmbeddingSiteWindow2
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(e932bf55-0a64-4beb-923a-1f32d3661044)]
interface nsIEmbeddingSiteWindow2 : nsIEmbeddingSiteWindow
{
    void blur();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIHelperAppLauncher
///////////////////////////////////////////////////////////////////////////////


interface nsIWebProgressListener2;
interface nsIMIMEInfo18;
interface nsIMIMEInfo;



[scriptable, object, uuid(99a0882d-2ff9-4659-9952-9ac531ba5592)]
interface nsIHelperAppLauncher18 : nsICancelable
{
    readonly attribute nsIMIMEInfo18 MIMEInfo;
    readonly attribute nsIURI source;
    readonly attribute AString suggestedFileName;

    void saveToDisk(in nsIFile new_file_location,
                    in boolean remember_this_preference);
                    
    void launchWithApplication(in nsIFile application,
                               in boolean remember_this_preference);
                               
    void setWebProgressListener(in nsIWebProgressListener2 web_progress_listener);
    
    void closeProgressWindow();
    
    readonly attribute nsIFile targetFile;
    readonly attribute PRTime timeDownloadStarted;
};

[scriptable, object, uuid(d9a19faf-497b-408c-b995-777d956b72c0)]
interface nsIHelperAppLauncher : nsICancelable
{
    readonly attribute nsIMIMEInfo MIMEInfo;
    readonly attribute nsIURI source;
    readonly attribute AString suggestedFileName;

    void saveToDisk(in nsIFile new_file_location,
                    in boolean remember_this_preference);

    void launchWithApplication(in nsIFile application,
                               in boolean remember_this_preference);

    void setWebProgressListener(in nsIWebProgressListener2 web_progress_listener);

    void closeProgressWindow();

    readonly attribute nsIFile targetFile;
    readonly attribute boolean targetFileIsExecutable;
    readonly attribute PRTime timeDownloadStarted;
    readonly attribute PRInt64 contentLength;
};



///////////////////////////////////////////////////////////////////////////////
//  nsIHelperAppLauncherDialog
///////////////////////////////////////////////////////////////////////////////


interface nsIHelperAppLauncher;
interface nsILocalFile;

[scriptable, object, uuid(64355793-988d-40a5-ba8e-fcde78cac631)]
interface nsIHelperAppLauncherDialog18 : nsISupports
{
    const unsigned long REASON_CANTHANDLE = 0;
    const unsigned long REASON_SERVERREQUEST = 1;
    const unsigned long REASON_TYPESNIFFED = 2;
    
    void show(in nsIHelperAppLauncher launcher,
              in nsISupports windowContext,
              in unsigned long reason);

    nsILocalFile promptForSaveToFile(
              in nsIHelperAppLauncher launcher,
              in nsISupports windowContext,
              in wstring defaultFile,
              in wstring suggestedFileExtension);
};


[scriptable, object, uuid(f3704fdc-8ae6-4eba-a3c3-f02958ac0649)]
interface nsIHelperAppLauncherDialog : nsISupports
{
    const unsigned long REASON_CANTHANDLE = 0;
    const unsigned long REASON_SERVERREQUEST = 1;
    const unsigned long REASON_TYPESNIFFED = 2;
    
    void show(in nsIHelperAppLauncher launcher,
              in nsISupports windowContext,
              in unsigned long reason);

    nsILocalFile promptForSaveToFile(
              in nsIHelperAppLauncher launcher,
              in nsISupports windowContext,
              in wstring defaultFile,
              in wstring suggestedFileExtension,
              in boolean force_prompt);
};



///////////////////////////////////////////////////////////////////////////////
//  nsIInputStream
///////////////////////////////////////////////////////////////////////////////


%{C++

typedef NS_CALLBACK(nsWriteSegmentFun)(
        nsIInputStream* in_stream,
        void* closure,
        const char* from_segment,
        PRUint32 to_offset,
        PRUint32 count,
        PRUint32* write_count
);

%}
native nsWriteSegmentFun(nsWriteSegmentFun);

  
[scriptable, uuid(fa9c7f6c-61b3-11d4-9877-00c04fa0cf4a)]
interface nsIInputStream : nsISupports
{
     void close();
     unsigned long available();
     [noscript] unsigned long read(in charPtr buf, in unsigned long count);
     // this line wasn't compiling on VC6, so we'll use a void ptr for now
     //[noscript] unsigned long readSegments(in nsWriteSegmentFun writer, in voidPtr closure, in unsigned long count);
     [noscript] unsigned long readSegments(in voidPtr writer, in voidPtr closure, in unsigned long count);
     boolean isNonBlocking();
};





///////////////////////////////////////////////////////////////////////////////
//  nsIIOService
///////////////////////////////////////////////////////////////////////////////


interface nsIProtocolHandler;
interface nsIChannel;


[scriptable, object, uuid(bddeda3f-9020-4d12-8c70-984ee9f7935e)]
interface nsIIOService : nsISupports
{
    nsIProtocolHandler getProtocolHandler(in string scheme);
    unsigned long getProtocolFlags(in string scheme);
    nsIURI newURI(in AUTF8String spec, in string origin_charset, in nsIURI base_uri);
    nsIURI newFileURI(in nsIFile file);
    nsIChannel newChannelFromURI(in nsIURI uri);
    nsIChannel newChannel(in AUTF8String spec,
                          in string origin_charset,
                          in nsIURI base_uri);
    
    attribute boolean offline;
    
    boolean allowPort(in long port, in string scheme);
    ACString extractScheme(in AUTF8String url_string);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIJSContextStack
///////////////////////////////////////////////////////////////////////////////


%{C++
struct JSContext;
%}

[ptr] native JSContext(JSContext);


[uuid(c67d8270-3189-11d3-9885-006008962422)]
interface nsIJSContextStack : nsISupports
{
    readonly attribute PRInt32 count;
    JSContext peek();
    JSContext pop();
    void push(in JSContext contxt);
};





///////////////////////////////////////////////////////////////////////////////
//  nsIMIMEInfo
///////////////////////////////////////////////////////////////////////////////


interface nsIUTF8StringEnumerator;
interface nsMIMEInfoHandleAction;
interface nsIHandlerApp;
interface nsIMutableArray;
interface nsIArray;
typedef long nsHandlerInfoAction;

[scriptable, uuid(1448b42f-cf0d-466e-9a15-64e876ebe857)]
interface nsIMIMEInfo18 : nsISupports
{
    nsIUTF8StringEnumerator getFileExtensions();
    void setFileExtensions(in AUTF8String extensions);
    boolean extensionExists(in AUTF8String extension);
    void appendExtension(in AUTF8String extension);

    attribute AUTF8String primaryExtension;
    readonly attribute ACString MIMEType;
    attribute AString description;
    attribute PRUint32 macType;
    attribute PRUint32 macCreator;

    boolean equals(in nsIMIMEInfo mime_info);

    attribute nsIFile preferredApplicationHandler;
    attribute AString applicationDescription;
    readonly attribute boolean hasDefaultHandler;
    readonly attribute AString defaultDescription;

    void launchWithFile(in nsIFile file);

    const long saveToDisk = 0;
    const long alwaysAsk = 1;
    const long useHelperApp = 2;
    const long handleInternally = 3;
    const long useSystemDefault = 4;

    attribute nsMIMEInfoHandleAction preferredAction;
    attribute boolean alwaysAskBeforeHandling;
};






[scriptable, uuid(325e56a7-3762-4312-aec7-f1fcf84b4145)] 
interface nsIHandlerInfo : nsISupports
{
    const long saveToDisk = 0;
    const long alwaysAsk = 1;
    const long useHelperApp = 2;
    const long handleInternally = 3;
    const long useSystemDefault = 4;
    
    readonly attribute ACString type;
    attribute AString description;
    attribute nsIHandlerApp preferredApplicationHandler;
    readonly attribute nsIMutableArray possibleApplicationHandlers;
    readonly attribute boolean hasDefaultHandler;
    readonly attribute AString defaultDescription;

    void launchWithURI(in nsIURI uri,
                       [optional] in nsIInterfaceRequestor window_context);

    attribute nsHandlerInfoAction preferredAction;

    attribute boolean alwaysAskBeforeHandling;
};


[scriptable, uuid(cd7083f8-5fe9-4248-bb09-0b0e2982fde8)]
interface nsIMIMEInfo : nsIHandlerInfo
{
    nsIUTF8StringEnumerator getFileExtensions();
    
    void setFileExtensions(in AUTF8String extensions);
    boolean extensionExists(in AUTF8String extension);
    void appendExtension(in AUTF8String extension);
    
    attribute AUTF8String primaryExtension;
    readonly attribute ACString MIMEType;
    attribute PRUint32 macType;
    attribute PRUint32 macCreator;
    
    boolean equals(in nsIMIMEInfo mime_info);
    
    readonly attribute nsIArray possibleLocalHandlers;
    
    void launchWithFile(in nsIFile file);
};



///////////////////////////////////////////////////////////////////////////////
//  nsIPref
///////////////////////////////////////////////////////////////////////////////

interface nsIFileSpec;
interface nsILocalFile;
interface nsIPrefBranch;
interface nsIObserver;

// nsIPrefBranch

[scriptable, uuid(56c35506-f14b-11d3-99d3-ddbfac2ccf65)]
interface nsIPrefBranch : nsISupports
{
  const long PREF_INVALID = 0;
  const long PREF_STRING = 32;
  const long PREF_INT = 64;
  const long PREF_BOOL = 128;

  readonly attribute string root;
  long getPrefType(in string aPrefName);
  boolean getBoolPref(in string aPrefName);
  void setBoolPref(in string aPrefName, in long aValue);
  string getCharPref(in string aPrefName);
  void setCharPref(in string aPrefName, in string aValue);
  long getIntPref(in string aPrefName);
  void setIntPref(in string aPrefName, in long aValue);
  void getComplexValue(in string aPrefName, in nsIIDRef aType,
                       [iid_is(aType), retval] out nsQIResult aValue);
  void setComplexValue(in string aPrefName, in nsIIDRef aType, in nsISupports aValue);
  void clearUserPref(in string aPrefName);
  void lockPref(in string aPrefName);
  boolean prefHasUserValue(in string aPrefName);
  boolean prefIsLocked(in string aPrefName);
  void    unlockPref(in string aPrefName);
  void deleteBranch(in string aStartingAt);

  void getChildList(in string aStartingAt,
                    [optional] out unsigned long aCount,
                    [array, size_is(aCount), retval] out string aChildArray);
  void resetBranch(in string aStartingAt);

};


%{C++

#define NS_PREFBRANCH_CONTRACTID "@mozilla.org/preferencesbranch;1"
#define NS_PREFBRANCH_CLASSNAME "Preferences Branch"

%}

// nsIPrefService

%{C++
struct PrefTuple;
template<class E, class A> class nsTArray;
struct nsTArrayInfallibleAllocator;
%}

[ptr] native nsPreferencesArrayPtr(nsTArray<PrefTuple, nsTArrayInfallibleAllocator>);
[ptr] native nsPreferencePtr(PrefTuple);
[ptr] native nsPreferencePtrConst(const PrefTuple);

interface nsIFile;
interface nsILocalFile;

[scriptable, uuid(decb9cc7-c08f-4ea5-be91-a8fc637ce2d2)]
interface nsIPrefService : nsISupports
{
  void readUserPrefs(in nsIFile aFile);
  void resetPrefs();
  void resetUserPrefs();
  void savePrefFile(in nsIFile aFile);
  nsIPrefBranch getBranch(in string aPrefRoot);
  nsIPrefBranch getDefaultBranch(in string aPrefRoot);
};

[scriptable, uuid(08c8cd2f-8345-45ee-938d-37ee6d3661b2)]
interface nsIPrefServiceInternal : nsISupports
{
  void readExtensionPrefs(in nsILocalFile aFile);

  [noscript] void mirrorPreferences(in nsPreferencesArrayPtr aArray);
  [noscript] void mirrorPreference(in ACString aPrefName, in nsPreferencePtr aPref);
  [noscript] boolean prefHasUserValue(in ACString aPrefName);
  [noscript] void setPreference(in nsPreferencePtrConst aPref);
  [noscript] void clearContentPref(in ACString aPrefName);
};

%{C++

#define NS_PREFSERVICE_CID                             \
  { /* {1cd91b88-1dd2-11b2-92e1-ed22ed298000} */       \
    0x91ca2441,                                        \
    0x050f,                                            \
    0x4f7c,                                            \
    { 0x9d, 0xf8, 0x75, 0xb4, 0x0e, 0xa4, 0x01, 0x56 } \
  }

#define NS_PREFSERVICE_CONTRACTID "@mozilla.org/preferences-service;1"
#define NS_PREFSERVICE_CLASSNAME "Preferences Server"
#define NS_PREFSERVICE_READ_TOPIC_ID "prefservice:before-read-userprefs"
#define NS_PREFSERVICE_RESET_TOPIC_ID "prefservice:before-reset"
#define NS_PREFSERVICE_APPDEFAULTS_TOPIC_ID "prefservice:after-app-defaults"

%}

///////////////////////////////////////////////////////////////////////////////
//  nsIWebBrowserPrint
///////////////////////////////////////////////////////////////////////////////

interface nsIPrintSettings18;
interface nsIPrintSettings;
interface nsIDOMWindow;
interface nsIWebProgressListener;

[scriptable, uuid(9a7ca4b0-fbba-11d4-a869-00105a183419)]
interface nsIWebBrowserPrint18 : nsISupports
{
    const short PRINTPREVIEW_GOTO_PAGENUM = 0;
    const short PRINTPREVIEW_PREV_PAGE = 1;
    const short PRINTPREVIEW_NEXT_PAGE = 2;
    const short PRINTPREVIEW_HOME = 3;
    const short PRINTPREVIEW_END = 4;

    readonly attribute nsIPrintSettings18 globalPrintSettings;
    readonly attribute nsIPrintSettings18 currentPrintSettings;
    readonly attribute nsIDOMWindow currentChildDOMWindow;
    readonly attribute boolean doingPrint;
    readonly attribute boolean doingPrintPreview;
    readonly attribute boolean isFramesetDocument;
    readonly attribute boolean isFramesetFrameSelected;
    readonly attribute boolean isIFrameSelected;
    readonly attribute boolean isRangeSelection;
    readonly attribute long printPreviewNumPages;

    void print(in nsIPrintSettings18 thePrintSettings,
               in nsIWebProgressListener WPListener);

    void printPreview(
                in nsIPrintSettings18 thePrintSettings,
                in nsIDOMWindow childDOMWin,
                in nsIWebProgressListener WPListener);

    void printPreviewNavigate(in short navType, in long pageNum);
    void cancel();
    void enumerateDocumentNames(
                out PRUint32 count,
                [retval, array, size_is(count)] out wstring result);
                
    void exitPrintPreview();
};

[scriptable, uuid(9a7ca4b0-fbba-11d4-a869-00105a183419)]
interface nsIWebBrowserPrint : nsISupports
{
    const short PRINTPREVIEW_GOTO_PAGENUM = 0;
    const short PRINTPREVIEW_PREV_PAGE = 1;
    const short PRINTPREVIEW_NEXT_PAGE = 2;
    const short PRINTPREVIEW_HOME = 3;
    const short PRINTPREVIEW_END = 4;

    readonly attribute nsIPrintSettings globalPrintSettings;
    readonly attribute nsIPrintSettings currentPrintSettings;
    readonly attribute nsIDOMWindow currentChildDOMWindow;
    readonly attribute boolean doingPrint;
    readonly attribute boolean doingPrintPreview;
    readonly attribute boolean isFramesetDocument;
    readonly attribute boolean isFramesetFrameSelected;
    readonly attribute boolean isIFrameSelected;
    readonly attribute boolean isRangeSelection;
    readonly attribute long printPreviewNumPages;

    void print(in nsIPrintSettings thePrintSettings,
               in nsIWebProgressListener WPListener);

    void printPreview(
                in nsIPrintSettings thePrintSettings,
                in nsIDOMWindow childDOMWin,
                in nsIWebProgressListener WPListener);

    void printPreviewNavigate(in short navType, in long pageNum);
    void cancel();
    void enumerateDocumentNames(
                out PRUint32 count,
                [retval, array, size_is(count)] out wstring result);
                
    void exitPrintPreview();
};


[scriptable, uuid(841387C8-72E6-484b-9296-BF6EEA80D58A)]
interface nsIPrintSettingsService : nsISupports
{
    readonly attribute nsIPrintSettings globalPrintSettings;
    readonly attribute nsIPrintSettings newPrintSettings;
    readonly attribute wstring defaultPrinterName;

    void initPrintSettingsFromPrinter(in wstring printer_name,
                                      in nsIPrintSettings print_settings);
                                      
    void initPrintSettingsFromPrefs(in nsIPrintSettings print_settings,
                                    in boolean use_printer_name_prefix,
                                    in unsigned long flags);
                                    
    void savePrintSettingsToPrefs(in nsIPrintSettings print_settings,
                                  in boolean user_printer_name_prefix,
                                  in unsigned long flags);
};


///////////////////////////////////////////////////////////////////////////////
//  nsIPrintSettings
///////////////////////////////////////////////////////////////////////////////

interface nsIPrintSession;

[scriptable, uuid(f1094df6-ce0e-42c9-9847-2f663172c38d)]
interface nsIPrintSettings18 : nsISupports
{
    const unsigned long kInitSaveOddEvenPages = 0x1;
    const unsigned long kInitSaveHeaderLeft = 0x2;
    const unsigned long kInitSaveHeaderCenter = 0x4;
    const unsigned long kInitSaveHeaderRight = 0x8;
    const unsigned long kInitSaveFooterLeft = 0x10;
    const unsigned long kInitSaveFooterCenter = 0x20;
    const unsigned long kInitSaveFooterRight = 0x40;
    const unsigned long kInitSaveBGColors = 0x80;
    const unsigned long kInitSaveBGImages = 0x100;
    const unsigned long kInitSavePaperSize = 0x200;
    const unsigned long kInitSavePaperName = 0x400;
    const unsigned long kInitSavePaperSizeUnit = 0x800;
    const unsigned long kInitSavePaperSizeType = 0x1000;
    const unsigned long kInitSavePaperData = 0x2000;
    const unsigned long kInitSavePaperWidth = 0x4000;
    const unsigned long kInitSavePaperHeight  = 0x8000;

    const unsigned long kInitSaveReversed = 0x10000;
    const unsigned long kInitSaveInColor = 0x20000;
    const unsigned long kInitSaveOrientation = 0x40000;
    const unsigned long kInitSavePrintCommand = 0x80000;
    const unsigned long kInitSavePrinterName = 0x100000;
    const unsigned long kInitSavePrintToFile = 0x200000;
    const unsigned long kInitSaveToFileName = 0x400000;
    const unsigned long kInitSavePageDelay = 0x800000;
    const unsigned long kInitSaveMargins = 0x1000000;
    const unsigned long kInitSaveNativeData = 0x2000000;
    const unsigned long kInitSavePlexName = 0x4000000;
    const unsigned long kInitSaveShrinkToFit = 0x8000000;
    const unsigned long kInitSaveScaling = 0x10000000;
    const unsigned long kInitSaveColorspace = 0x20000000;
    const unsigned long kInitSaveResolutionName = 0x40000000;
    const unsigned long kInitSaveDownloadFonts = 0x80000000;
    const unsigned long kInitSaveAll = 0xFFFFFFFF;

    const long kPrintOddPages = 0x1;
    const long kPrintEvenPages = 0x2;
    const long kEnableSelectionRB = 0x4;

    const long kRangeAllPages = 0;
    const long kRangeSpecifiedPageRange = 1;
    const long kRangeSelection = 2;
    const long kRangeFocusFrame = 3;

    const long kJustLeft = 0;
    const long kJustCenter = 1;
    const long kJustRight = 2;

    const short kUseInternalDefault = 0;
    const short kUseSettingWhenPossible = 1;

    const short kPaperSizeNativeData = 0;
    const short kPaperSizeDefined = 1;

    const short kPaperSizeInches = 0;
    const short kPaperSizeMillimeters = 1;

    const short kPortraitOrientation = 0;
    const short kLandscapeOrientation = 1;

    const short kNoFrames = 0;
    const short kFramesAsIs = 1;
    const short kSelectedFrame = 2;
    const short kEachFrameSep = 3;

    const short kFrameEnableNone = 0;
    const short kFrameEnableAll = 1;
    const short kFrameEnableAsIsAndEach = 2;

    void SetPrintOptions(in long type, in boolean turnOnOff);
    boolean GetPrintOptions(in long type);
    long GetPrintOptionsBits();
    void GetPageSizeInTwips(out long width, out long height);
    nsIPrintSettings clone();
    void assign(in nsIPrintSettings ps);

    [noscript] attribute nsIPrintSession printSession;
    attribute long startPageRange;
    attribute long endPageRange;
    attribute double marginTop;
    attribute double marginLeft;
    attribute double marginBottom;
    attribute double marginRight;
    attribute double scaling;
    attribute boolean printBGColors;
    attribute boolean printBGImages;
    attribute short printRange;
    attribute wstring title;
    attribute wstring docURL;
    attribute wstring headerStrLeft;
    attribute wstring headerStrCenter;
    attribute wstring headerStrRight;
    attribute wstring footerStrLeft;
    attribute wstring footerStrCenter;
    attribute wstring footerStrRight;
    attribute short howToEnableFrameUI;
    attribute boolean isCancelled;
    attribute short printFrameTypeUsage;
    attribute short printFrameType;
    attribute boolean printSilent;
    attribute boolean shrinkToFit;
    attribute boolean showPrintProgress;
    attribute wstring paperName;
    attribute short paperSizeType;
    attribute short paperData;
    attribute double paperWidth;
    attribute double paperHeight;
    attribute short paperSizeUnit;
    attribute wstring plexName;
    attribute wstring colorspace;
    attribute wstring resolutionName;
    attribute boolean downloadFonts;
    attribute boolean printReversed;
    attribute boolean printInColor;
    attribute long paperSize;
    attribute long orientation;
    attribute wstring printCommand;
    attribute long numCopies;
    attribute wstring printerName;
    attribute boolean printToFile;
    attribute wstring toFileName;
    attribute long printPageDelay;
    attribute boolean isInitializedFromPrinter;
    attribute boolean isInitializedFromPrefs;
};


[scriptable, uuid(5af07661-6477-4235-8814-4a45215855b8)]
interface nsIPrintSettings : nsISupports
{
    const unsigned long kInitSaveOddEvenPages = 0x1;
    const unsigned long kInitSaveHeaderLeft = 0x2;
    const unsigned long kInitSaveHeaderCenter = 0x4;
    const unsigned long kInitSaveHeaderRight = 0x8;
    const unsigned long kInitSaveFooterLeft = 0x10;
    const unsigned long kInitSaveFooterCenter = 0x20;
    const unsigned long kInitSaveFooterRight = 0x40;
    const unsigned long kInitSaveBGColors = 0x80;
    const unsigned long kInitSaveBGImages = 0x100;
    const unsigned long kInitSavePaperSize = 0x200;
    const unsigned long kInitSavePaperData = 0x2000;
    const unsigned long kInitSaveUnwriteableMargins = 0x4000;
    const unsigned long kInitSaveEdges = 0x8000;
    const unsigned long kInitSaveReversed = 0x10000;
    const unsigned long kInitSaveInColor = 0x20000;
    const unsigned long kInitSaveOrientation = 0x40000;
    const unsigned long kInitSavePrintCommand = 0x80000;
    const unsigned long kInitSavePrinterName = 0x100000;
    const unsigned long kInitSavePrintToFile = 0x200000;
    const unsigned long kInitSaveToFileName = 0x400000;
    const unsigned long kInitSavePageDelay = 0x800000;
    const unsigned long kInitSaveMargins = 0x1000000;
    const unsigned long kInitSaveNativeData = 0x2000000;
    const unsigned long kInitSavePlexName = 0x4000000;
    const unsigned long kInitSaveShrinkToFit = 0x8000000;
    const unsigned long kInitSaveScaling = 0x10000000;
    const unsigned long kInitSaveColorspace = 0x20000000;
    const unsigned long kInitSaveResolutionName = 0x40000000;
    const unsigned long kInitSaveDownloadFonts = 0x80000000;
    const unsigned long kInitSaveAll = 0xffffffff;
    const long kPrintOddPages = 0x1;
    const long kPrintEvenPages = 0x2;
    const long kEnableSelectionRB = 0x4;
    const long kRangeAllPages = 0;
    const long kRangeSpecifiedPageRange = 1;
    const long kRangeSelection = 2;
    const long kRangeFocusFrame = 3;
    const long kJustLeft = 0;
    const long kJustCenter = 1;
    const long kJustRight = 2;
    const short kUseInternalDefault = 0;
    const short kUseSettingWhenPossible = 1;
    const short kPaperSizeNativeData = 0;
    const short kPaperSizeDefined = 1;
    const short kPaperSizeInches = 0;
    const short kPaperSizeMillimeters = 1;
    const short kPortraitOrientation = 0;
    const short kLandscapeOrientation = 1;
    const short kNoFrames = 0;
    const short kFramesAsIs = 1;
    const short kSelectedFrame = 2;
    const short kEachFrameSep = 3;
    const short kFrameEnableNone = 0;
    const short kFrameEnableAll = 1;
    const short kFrameEnableAsIsAndEach = 2;
    const short kOutputFormatNative = 0;
    const short kOutputFormatPS = 1;
    const short kOutputFormatPDF = 2;
    void SetPrintOptions(in PRInt32 type, in boolean turn_on_off);
    boolean GetPrintOptions(in PRInt32 type);
    PRInt32 GetPrintOptionsBits();
    void GetEffectivePageSize(out double width, out double height);
    nsIPrintSettings clone();
    void assign(in nsIPrintSettings print_settings);

    [noscript] attribute nsIPrintSession printSession; /* We hold a weak reference */

    attribute long startPageRange; 
    attribute long endPageRange; 
    attribute double edgeTop;
    attribute double edgeLeft;
    attribute double edgeBottom;
    attribute double edgeRight;
    attribute double marginTop;
    attribute double marginLeft;
    attribute double marginBottom;
    attribute double marginRight;
    attribute double unwriteableMarginTop;
    attribute double unwriteableMarginLeft;
    attribute double unwriteableMarginBottom;
    attribute double unwriteableMarginRight;
    attribute double scaling;
    attribute boolean printBGColors;
    attribute boolean printBGImages;
    attribute short printRange; 
    attribute wstring title;
    attribute wstring docURL;
    attribute wstring headerStrLeft;
    attribute wstring headerStrCenter;
    attribute wstring headerStrRight;
    attribute wstring footerStrLeft;
    attribute wstring footerStrCenter;
    attribute wstring footerStrRight;
    attribute short howToEnableFrameUI;
    attribute boolean isCancelled;
    attribute short printFrameTypeUsage;
    attribute short printFrameType;
    attribute boolean printSilent;
    attribute boolean shrinkToFit;
    attribute boolean showPrintProgress;
    attribute wstring paperName;
    attribute short paperSizeType;
    attribute short paperData;
    attribute double paperWidth;
    attribute double paperHeight;
    attribute short paperSizeUnit;
    attribute wstring plexName;
    attribute wstring colorspace;
    attribute wstring resolutionName;
    attribute boolean downloadFonts;
    attribute boolean printReversed;
    attribute boolean printInColor;
    attribute long orientation;
    attribute wstring printCommand;
    attribute long numCopies;
    attribute wstring printerName;
    attribute boolean printToFile;
    attribute wstring toFileName;
    attribute short outputFormat;
    attribute long printPageDelay;
    attribute boolean isInitializedFromPrinter;
    attribute boolean isInitializedFromPrefs;
/*
    [noscript] void SetMarginInTwips(in nsNativeMarginRef aMargin);
    [noscript] void SetEdgeInTwips(in nsNativeMarginRef aEdge);
    [noscript] void GetMarginInTwips(in nsNativeMarginRef aMargin);
    [noscript] void GetEdgeInTwips(in nsNativeMarginRef aEdge);
    [noscript] void SetupSilentPrinting();
    [noscript] void SetUnwriteableMarginInTwips(in nsNativeMarginRef aEdge);
    [noscript] void GetUnwriteableMarginInTwips(in nsNativeMarginRef aEdge);
*/
};





///////////////////////////////////////////////////////////////////////////////
//  nsIPromptService
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMWindow;

[scriptable, uuid(1630c61a-325e-49ca-8759-a31b16c47aa5)]
interface nsIPromptService : nsISupports
{
    void alert(in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text);
               
    void alertCheck(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text,
               in wstring check_msg,
               inout boolean check_state);
               
    boolean confirm(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text);
               
    boolean confirmCheck(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text,
               in wstring check_msg,
               inout boolean check_state);
        
    const unsigned long BUTTON_POS_0 = 1;
    const unsigned long BUTTON_POS_1 = 256;
    const unsigned long BUTTON_POS_2 = 65536;
    const unsigned long BUTTON_TITLE_OK = 1;
    const unsigned long BUTTON_TITLE_CANCEL = 2;
    const unsigned long BUTTON_TITLE_YES = 3;
    const unsigned long BUTTON_TITLE_NO = 4;
    const unsigned long BUTTON_TITLE_SAVE = 5;
    const unsigned long BUTTON_TITLE_DONT_SAVE = 6;
    const unsigned long BUTTON_TITLE_REVERT = 7;
    const unsigned long BUTTON_TITLE_IS_STRING = 127;
    const unsigned long BUTTON_POS_0_DEFAULT = 0;
    const unsigned long BUTTON_POS_1_DEFAULT = 16777216;
    const unsigned long BUTTON_POS_2_DEFAULT = 33554432;
    const unsigned long BUTTON_DELAY_ENABLE = 67108864;
    const unsigned long STD_OK_CANCEL_BUTTONS = 513;
    const unsigned long STD_YES_NO_BUTTONS = 1027;
    
    
    PRInt32 confirmEx(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text,
               in unsigned long button_flags,
               in wstring button0_title,
               in wstring button1_title,
               in wstring button2_title,
               in wstring check_msg,
               inout boolean check_state);

    boolean prompt(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text,
               inout wstring value,
               in wstring check_msg,
               inout boolean check_state);

    boolean promptUsernameAndPassword(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text,
               inout wstring username,
               inout wstring password,
               in wstring check_msg,
               inout boolean check_state);

    boolean promptPassword(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text,
               inout wstring password,
               in wstring check_msg,
               inout boolean check_state);

    boolean select(
               in nsIDOMWindow parent,
               in wstring dialog_title,
               in wstring text,
               in PRUint32 count,
               [array, size_is(count)] in wstring select_list,
               out long out_selection);
};


interface nsIAuthInformation;
interface nsIAuthPromptCallback;

[scriptable, uuid(cf86d196-dbee-4482-9dfa-3477aa128319)]
interface nsIPromptService2 : nsIPromptService
{
    boolean promptAuth(
                in nsIDOMWindow parent,
                in nsIChannel channel,
                in PRUint32 level,
                in nsIAuthInformation auth_info,
                in wstring checkbox_label,
                inout boolean check_value);

    nsICancelable asyncPromptAuth(
                in nsIDOMWindow parent,
                in nsIChannel channel,
                in nsIAuthPromptCallback callbck,
                in nsISupports contxt,
                in PRUint32 level,
                in nsIAuthInformation auth_info,
                in wstring checkbox_label,
                inout boolean check_value);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIAuthInformation
///////////////////////////////////////////////////////////////////////////////

[scriptable, uuid(0d73639c-2a92-4518-9f92-28f71fea5f20)]
interface nsIAuthInformation : nsISupports
{
    const PRUint32 AUTH_HOST = 1;
    const PRUint32 AUTH_PROXY = 2;
    const PRUint32 NEED_DOMAIN = 4;
    const PRUint32 ONLY_PASSWORD = 8;
    const PRUint32 PREVIOUS_FAILED = 16;

    readonly attribute unsigned long flags;
    readonly attribute AString realm;
    readonly attribute AUTF8String authenticationScheme;
    attribute AString username;
    attribute AString password;
    attribute AString domain;
};



///////////////////////////////////////////////////////////////////////////////
//  nsIProperties
///////////////////////////////////////////////////////////////////////////////

[scriptable, uuid(78650582-4e93-4b60-8e85-26ebd3eb14ca)]
interface nsIProperties : nsISupports
{
    void get(in string prop_name,
             in nsIIDRef iid,
             [iid_is(iid), retval] out nsQIResult result);

    void set(in string prop_name,
             in nsISupports value);

    boolean has(in string prop_name);
    
    void undefine(in string prop_name);

    void getKeys(out PRUint32 count,
                 [array, size_is(count), retval] out string keys);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIRequestObserver
///////////////////////////////////////////////////////////////////////////////


interface nsIRequest;


[scriptable, uuid(fd91e2e0-1481-11d3-9333-00104ba0fd40)]
interface nsIRequestObserver : nsISupports
{
    void onStartRequest(in nsIRequest request,
                        in nsISupports contxt);
                        
    void onStopRequest(in nsIRequest request,
                       in nsISupports contxt,
                       in nsresult status_code);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIServiceManager
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(8bb35ed9-e332-462d-9155-4a002ab5c958)]
interface nsIServiceManager : nsISupports
{
    void getService(in nsCIDRef class_id,
                    in nsIIDRef iid,
                    [iid_is(iid), retval] out nsQIResult result);
                    
    void getServiceByContractID(
                    in string contract_id,
                    in nsIIDRef iid,
                    [iid_is(iid), retval] out nsQIResult result);
                    
    boolean isServiceInstantiated(
                    in nsCIDRef class_id,
                    in nsIIDRef iid);
                    
    boolean isServiceInstantiatedByContractID(
                    in string contract_id,
                    in nsIIDRef iid);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIStreamListener
///////////////////////////////////////////////////////////////////////////////


interface nsIRequest;
interface nsIInputStream;


[scriptable, uuid(1a637020-1482-11d3-9333-00104ba0fd40)]
interface nsIStreamListener : nsIRequestObserver
{
    void onDataAvailable(
            in nsIRequest request,
            in nsISupports contxt,
            in nsIInputStream input_stream,
            in unsigned long offset,
            in unsigned long count);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIStringInputStream
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(450cd2d4-f0fd-424d-b365-b1251f80fd53)]
interface nsIStringInputStream : nsIInputStream
{
    void setData(in string data, in long dataLen);
    [noscript] void adoptData(in charPtr data, in long data_len);
    [noscript] void shareData(in string data, in long data_len);
};




///////////////////////////////////////////////////////////////////////////////
//  nsITooltipListener
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(44b78386-1dd2-11b2-9ad2-e4eee2ca1916)]
interface nsITooltipListener : nsISupports
{
    void onShowTooltip(in long x_coords,
                       in long y_coords,
                       in wstring tip_text);
    void onHideTooltip();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebProgressListener
///////////////////////////////////////////////////////////////////////////////


interface nsIWebProgress;
interface nsIRequest;

[scriptable, uuid(570f39d1-efd0-11d3-b093-00a024ffc08c)]
interface nsIWebProgressListener : nsISupports
{
    const unsigned long STATE_START = 1;
    const unsigned long STATE_REDIRECTING = 2;
    const unsigned long STATE_TRANSFERRING = 4;
    const unsigned long STATE_NEGOTIATING = 8;
    const unsigned long STATE_STOP = 16;

    const unsigned long STATE_IS_REQUEST = 65536;
    const unsigned long STATE_IS_DOCUMENT = 131072;
    const unsigned long STATE_IS_NETWORK = 262144;
    const unsigned long STATE_IS_WINDOW = 524288;
    
    const unsigned long STATE_RESTORING = 16777216;

    const unsigned long STATE_IS_INSECURE = 4;
    const unsigned long STATE_IS_BROKEN = 1;
    const unsigned long STATE_IS_SECURE = 2;

    const unsigned long STATE_SECURE_HIGH = 262144;
    const unsigned long STATE_SECURE_MED = 65536;
    const unsigned long STATE_SECURE_LOW = 131072;

    void onStateChange(in nsIWebProgress web_progress,
                       in nsIRequest request,
                       in unsigned long state_flags,
                       in nsresult status);
                       
    void onProgressChange(in nsIWebProgress web_progress,
                          in nsIRequest request,
                          in long cur_self_progress,
                          in long max_self_progress,
                          in long cur_total_progress,
                          in long max_total_progress);
                      
    void onLocationChange(in nsIWebProgress web_progress,
                          in nsIRequest request,
                          in nsIURI location);
                          
    void onStatusChange(in nsIWebProgress web_progress,
                        in nsIRequest request,
                        in nsresult status,
                        in wstring message);
               
    void onSecurityChange(in nsIWebProgress web_progress,
                          in nsIRequest request,
                          in unsigned long state);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebProgressListener2
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(3f24610d-1e1f-4151-9d2e-239884742324)]
interface nsIWebProgressListener2_18 : nsIWebProgressListener
{
    void onProgressChange64(in nsIWebProgress web_progress,
                            in nsIRequest request,
                            in long long cur_self_progress,
                            in long long max_self_progress,
                            in long long cur_total_progress,
                            in long long max_total_progress);
};

[scriptable, uuid(dde39de0-e4e0-11da-8ad9-0800200c9a66)]
interface nsIWebProgressListener2 : nsIWebProgressListener
{
    void onProgressChange64(in nsIWebProgress web_progress,
                            in nsIRequest request,
                            in long long cur_self_progress,
                            in long long max_self_progress,
                            in long long cur_total_progress,
                            in long long max_total_progress);

    boolean onRefreshAttempted(
                            in nsIWebProgress web_progress,
                            in nsIURI refresh_uri,
                            in long millis,
                            in boolean same_uri);
};


///////////////////////////////////////////////////////////////////////////////
//  nsITransfer
///////////////////////////////////////////////////////////////////////////////


interface nsIMIMEInfo;
interface nsILocalFile;
interface nsICancelable;


//[scriptable, uuid(23c51569-e9a1-4a92-adeb-3723db82ef7c)]
[scriptable, uuid(3a982955-dc44-422e-8734-8462bf8d2121)]
interface nsITransfer : nsIWebProgressListener2
{
    void init(in nsIURI source,
              in nsIURI target,
              in AString display_name,
              in nsIMIMEInfo mime_info,
              in PRTime start_time,
              in nsILocalFile temp_file,
              in nsICancelable cancelable);
};



///////////////////////////////////////////////////////////////////////////////
//  nsIURIContentListener
///////////////////////////////////////////////////////////////////////////////


interface nsIRequest;
interface nsIStreamListener;
interface nsIURIContentListener;

[scriptable, uuid(94928ab3-8b63-11d3-989d-001083010e9b)]
interface nsIURIContentListener : nsISupports
{
    boolean onStartURIOpen(in nsIURI uri);
    
    boolean doContent(in string content_type,
                      in boolean is_content_preferred,
                      in nsIRequest request,
                      out nsIStreamListener content_handler);
    
    boolean isPreferred(
                      in string content_type,
                      out string desired_content_type);
                      
    boolean canHandleContent(
                      in string content_type,
                      in boolean is_content_preferred,
                      out string desired_content_type);
               
    attribute nsISupports loadCookie;
    attribute nsIURIContentListener parentContentListener;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIURILoader
///////////////////////////////////////////////////////////////////////////////


interface nsIURIContentListener;
interface nsIChannel;
interface nsIInterfaceRequestor;
interface nsIStreamListener;


[scriptable, uuid(2f7e8051-f1c9-4bcc-8584-9cfd5849e343)]
interface nsIURILoader : nsISupports
{
    const unsigned long IS_CONTENT_PREFERRED = 0x01;
    const unsigned long DONT_RETARGET = 0x02;

    void registerContentListener(in nsIURIContentListener content_listener);
    void unRegisterContentListener(in nsIURIContentListener content_listener);
    
    void openURI(in nsIChannel channel,
                 in boolean is_content_preferred,
                 in nsIInterfaceRequestor window_context);
    
    nsIStreamListener openChannel(in nsIChannel channel,
                                  in unsigned long flags,
                                  in nsIInterfaceRequestor window_context);

    void stop(in nsISupports load_cookie);
};



[scriptable, uuid(5cf6420c-74f3-4a7c-bc1d-f5756d79ea07)]
interface ns18IURILoader : nsISupports
{
    void registerContentListener(in nsIURIContentListener content_listener);
    void unRegisterContentListener(in nsIURIContentListener content_listener);

    void openURI(in nsIChannel channel,
                 in boolean is_content_preferred,
                 in nsIInterfaceRequestor window_context);

    void stop(in nsISupports load_cookie);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebBrowser
///////////////////////////////////////////////////////////////////////////////


interface nsIWebBrowserChrome;
interface nsIURIContentListener;
interface nsIDOMWindow;
interface nsIWeakReference;

//[scriptable, uuid(69e5df00-7b8b-11d3-af61-00a024ffc08c)]
[scriptable, uuid(33e9d001-caab-4ba9-8961-54902f197202)]
interface nsIWebBrowser : nsISupports
{
    void addWebBrowserListener(in nsIWeakReference listener, in nsIIDRef iid);
    void removeWebBrowserListener(in nsIWeakReference listener, in nsIIDRef iid);
    
    attribute nsIWebBrowserChrome containerWindow;
    attribute nsIURIContentListener parentURIContentListener;
    readonly attribute nsIDOMWindow contentDOMWindow;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebBrowserChrome
///////////////////////////////////////////////////////////////////////////////


interface nsIWebBrowser;
interface nsIDocShellTreeItem;

[scriptable, uuid(ba434c60-9d52-11d3-afb0-00a024ffc08c)]
interface nsIWebBrowserChrome : nsISupports
{
    void setStatus(in unsigned long status_type, in wstring status);
    attribute nsIWebBrowser webBrowser;
    
    const unsigned long STATUS_SCRIPT=0x00000001;
    const unsigned long STATUS_SCRIPT_DEFAULT=0x00000002;
    const unsigned long STATUS_LINK=0x00000003;

    const unsigned long CHROME_DEFAULT=0x00000001;
    const unsigned long CHROME_WINDOW_BORDERS=0x00000002;
    const unsigned long CHROME_WINDOW_CLOSE=0x00000004;
    const unsigned long CHROME_WINDOW_RESIZE=0x00000008;
    const unsigned long CHROME_MENUBAR=0x00000010;
    const unsigned long CHROME_TOOLBAR=0x00000020;
    const unsigned long CHROME_LOCATIONBAR=0x00000040;
    const unsigned long CHROME_STATUSBAR=0x00000080;
    const unsigned long CHROME_PERSONAL_TOOLBAR=0x00000100;
    const unsigned long CHROME_SCROLLBARS=0x00000200;
    const unsigned long CHROME_TITLEBAR=0x00000400;

    const unsigned long CHROME_WITH_SIZE=0x00001000;
    const unsigned long CHROME_WITH_POSITION=0x00002000;

    const unsigned long CHROME_WINDOW_MIN=0x00004000;
    const unsigned long CHROME_WINDOW_POPUP=0x00008000;
    const unsigned long CHROME_WINDOW_RAISED=0x02000000;
    const unsigned long CHROME_WINDOW_LOWERED=0x04000000;
    const unsigned long CHROME_CENTER_SCREEN=0x08000000;
    const unsigned long CHROME_DEPENDENT=0x10000000;
    const unsigned long CHROME_MODAL=0x20000000;
    const unsigned long CHROME_OPENAS_DIALOG=0x40000000;
    const unsigned long CHROME_OPENAS_CHROME =0x80000000;
    const unsigned long CHROME_ALL=0x00000ffe;
    
    attribute unsigned long chromeFlags;
    
    void destroyBrowserWindow();
    void sizeBrowserTo(in long cx, in long cy);
    void showAsModal();
    boolean isWindowModal();
    void exitModalEventLoop(in nsresult status);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebBrowserChromeFocus
///////////////////////////////////////////////////////////////////////////////


[scriptable, uuid(d2206418-1dd1-11b2-8e55-acddcd2bcfb8)]
interface nsIWebBrowserChromeFocus : nsISupports
{
    void focusNextElement();
    void focusPrevElement();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebBrowserFind
///////////////////////////////////////////////////////////////////////////////


[scriptable, object, uuid(2f977d44-5485-11d4-87e2-0010a4e75ef2)]
interface nsIWebBrowserFind : nsISupports
{
    boolean findNext();

    attribute wstring searchString;
    attribute boolean findBackwards;
    attribute boolean wrapFind;
    attribute boolean entireWord;
    attribute boolean matchCase;
    attribute boolean searchFrames;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebBrowserFocus
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMWindow;
interface nsIDOMElement;

[scriptable, uuid(9c5d3c58-1dd1-11b2-a1c9-f3699284657a)]
interface nsIWebBrowserFocus : nsISupports
{
    void activate();
    void deactivate();
    void setFocusAtFirstElement();
    void setFocusAtLastElement();
    
    attribute nsIDOMWindow focusedWindow;
    attribute nsIDOMElement focusedElement;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebBrowserPersist
///////////////////////////////////////////////////////////////////////////////


interface nsIChannel;
interface nsIWebProgressListener;
interface nsIInputStream;
interface nsIDOMDocument;


[scriptable, uuid(dd4e0a6a-210f-419a-ad85-40e8543b9465)]
interface nsIWebBrowserPersist : nsICancelable
{
    const unsigned long PERSIST_FLAGS_NONE = 0;
    const unsigned long PERSIST_FLAGS_FROM_CACHE = 1;
    const unsigned long PERSIST_FLAGS_BYPASS_CACHE = 2;
    const unsigned long PERSIST_FLAGS_IGNORE_REDIRECTED_DATA = 4;
    const unsigned long PERSIST_FLAGS_IGNORE_IFRAMES = 8;
    const unsigned long PERSIST_FLAGS_NO_CONVERSION = 16;
    const unsigned long PERSIST_FLAGS_REPLACE_EXISTING_FILES = 32;
    const unsigned long PERSIST_FLAGS_NO_BASE_TAG_MODIFICATIONS = 64;
    const unsigned long PERSIST_FLAGS_FIXUP_ORIGINAL_DOM = 128;
    const unsigned long PERSIST_FLAGS_FIXUP_LINKS_TO_DESTINATION = 256;
    const unsigned long PERSIST_FLAGS_DONT_FIXUP_LINKS = 512;
    const unsigned long PERSIST_FLAGS_SERIALIZE_OUTPUT = 1024;
    const unsigned long PERSIST_FLAGS_DONT_CHANGE_FILENAMES = 2048;
    const unsigned long PERSIST_FLAGS_FAIL_ON_BROKEN_LINKS = 4096;
    const unsigned long PERSIST_FLAGS_CLEANUP_ON_FAILURE = 8192;
    const unsigned long PERSIST_FLAGS_AUTODETECT_APPLY_CONVERSION = 16384;
    const unsigned long PERSIST_FLAGS_APPEND_TO_FILE = 32768;
    const unsigned long PERSIST_FLAGS_FORCE_ALLOW_COOKIES = 65536;
    
    const unsigned long PERSIST_STATE_READY = 1;
    const unsigned long PERSIST_STATE_SAVING = 2;
    const unsigned long PERSIST_STATE_FINISHED = 3;
    
    const unsigned long ENCODE_FLAGS_SELECTION_ONLY = 1;
    const unsigned long ENCODE_FLAGS_FORMATTED = 2;
    const unsigned long ENCODE_FLAGS_RAW = 4;
    const unsigned long ENCODE_FLAGS_BODY_ONLY = 8;
    const unsigned long ENCODE_FLAGS_PREFORMATTED = 16;
    const unsigned long ENCODE_FLAGS_WRAP = 32;
    const unsigned long ENCODE_FLAGS_FORMAT_FLOWED = 64;
    const unsigned long ENCODE_FLAGS_ABSOLUTE_LINKS = 128;
    const unsigned long ENCODE_FLAGS_ENCODE_W3C_ENTITIES = 256;
    const unsigned long ENCODE_FLAGS_CR_LINEBREAKS = 512;
    const unsigned long ENCODE_FLAGS_LF_LINEBREAKS = 1024;
    const unsigned long ENCODE_FLAGS_NOSCRIPT_CONTENT = 2048;
    const unsigned long ENCODE_FLAGS_NOFRAMES_CONTENT = 4096;
    const unsigned long ENCODE_FLAGS_ENCODE_BASIC_ENTITIES = 8192;
    const unsigned long ENCODE_FLAGS_ENCODE_LATIN1_ENTITIES = 16384;
    const unsigned long ENCODE_FLAGS_ENCODE_HTML_ENTITIES = 32768;

    attribute unsigned long persistFlags;
    readonly attribute unsigned long currentState;
    readonly attribute unsigned long result;
    attribute nsIWebProgressListener progressListener;
    
    void saveURI(in nsIURI uri,
                 in nsISupports cache_key,
                 in nsIURI referrer,
                 in nsIInputStream post_data,
                 in string extra_headers,
                 in nsIFile file);
                 
    void saveChannel(in nsIChannel channel,
                     in nsISupports file);
        
    void saveDocument(in nsIDOMDocument document,
                      in nsISupports file,
                      in nsISupports data_path,
                      in string output_content_type,
                      in unsigned long encoding_flags,
                      in unsigned long wrap_column);

    void cancelSave();
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWebNavigation
///////////////////////////////////////////////////////////////////////////////


interface nsIInputStream;
interface nsIDOMDocument;
interface nsISHistory;
interface nsIURI;

[scriptable, uuid(f5d9e7b0-d930-11d3-b057-00a024ffc08c)]
interface nsIWebNavigation : nsISupports
{
    readonly attribute boolean canGoBack;
    readonly attribute boolean canGoForward;
    
    void goBack();
    void goForward();
    void gotoIndex(in long index);
    
    const unsigned long LOAD_FLAGS_MASK = 65535;
    const unsigned long LOAD_FLAGS_NONE = 0;
    const unsigned long LOAD_FLAGS_IS_REFRESH = 16;
    const unsigned long LOAD_FLAGS_IS_LINK = 32;
    const unsigned long LOAD_FLAGS_BYPASS_HISTORY = 64;
    const unsigned long LOAD_FLAGS_REPLACE_HISTORY = 128;
    const unsigned long LOAD_FLAGS_BYPASS_CACHE = 256;
    const unsigned long LOAD_FLAGS_BYPASS_PROXY = 512;
    const unsigned long LOAD_FLAGS_CHARSET_CHANGE = 1024;
    const unsigned long LOAD_FLAGS_STOP_CONTENT = 2048;
    const unsigned long LOAD_FLAGS_FROM_EXTERNAL = 4096;
    const unsigned long STOP_NETWORK = 1;
    const unsigned long STOP_CONTENT = 2;
    const unsigned long STOP_ALL = 3;
    const unsigned long LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP = 0x2000;
    const unsigned long LOAD_FLAGS_FIRST_LOAD = 0x4000;
    const unsigned long LOAD_FLAGS_FORCE_ALLOW_COOKIES = 0x20000;
    
    void loadURI(in wstring uri,
                 in unsigned long load_flags,
                 in nsIURI referrer,
                 in nsIInputStream post_data,
                 in nsIInputStream headers);

    void reload(in unsigned long reload_flags);
    void stop(in unsigned long stop_flags);
    
    readonly attribute nsIDOMDocument document;
    readonly attribute nsIURI currentURI;
    readonly attribute nsIURI referringURI;
    attribute nsISHistory sessionHistory;
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWindowCreator
///////////////////////////////////////////////////////////////////////////////


interface nsIWebBrowserChrome;

[scriptable, uuid(30465632-a777-44cc-90f9-8145475ef999)]
interface nsIWindowCreator : nsISupports
{
    nsIWebBrowserChrome createChromeWindow(in nsIWebBrowserChrome parent,
                                           in unsigned long chrome_flags);
};




///////////////////////////////////////////////////////////////////////////////
//  nsIWindowWatcher
///////////////////////////////////////////////////////////////////////////////


interface nsIDOMWindow;
interface nsIObserver;
interface nsISimpleEnumerator;
interface nsIAuthPrompt;
interface nsIWebBrowserChrome;
interface nsIPrompt;
interface nsIWindowCreator;

[scriptable, uuid(002286a8-494b-43b3-8ddd-49e3fc50622b)]
interface nsIWindowWatcher : nsISupports
{
    nsIDOMWindow openWindow(in nsIDOMWindow parent,
                            in string url,
                            in string name,
                            in string features,
                            in nsISupports arguments);
                            
    void registerNotification(in nsIObserver observer);
    void unregisterNotification(in nsIObserver observer);
    
    nsISimpleEnumerator getWindowEnumerator();
    nsIPrompt getNewPrompter(in nsIDOMWindow parent);
    nsIAuthPrompt getNewAuthPrompter(in nsIDOMWindow parent);
    void setWindowCreator(in nsIWindowCreator creator);
                            
    nsIWebBrowserChrome getChromeForWindow(in nsIDOMWindow window);
    
    nsIDOMWindow getWindowByName(in wstring target_name,
                                 in nsIDOMWindow current_window);
                                 
    attribute nsIDOMWindow activeWindow;
};
%{C++
// {002286a8-494b-43b3-8ddd-49e3fc50622b}
#define NS_WINDOWWATCHER_IID \
 {0x002286a8, 0x494b, 0x43b3, {0x8d, 0xdd, 0x49, 0xe3, 0xfc, 0x50, 0x62, 0x2b}}

#define NS_WINDOWWATCHER_CONTRACTID "@mozilla.org/embedcomp/window-watcher;1"
%}



///////////////////////////////////////////////////////////////////////////////
//  nsIXPCSecurityManager
///////////////////////////////////////////////////////////////////////////////


%{C++
struct JSObject;
typedef long jsval;
typedef struct jsid { size_t asBits; } jsid;
%}

[ptr] native JSContextPtr(JSContext);
[ptr] native JSObjectPtr(JSObject);
interface nsIClassInfo;
interface nsIXPCNativeCallContext;

[uuid(31431440-f1ce-11d2-985a-006008962422)]
interface nsIXPCSecurityManager : nsISupports
{
    void CanCreateWrapper(
                   in JSContextPtr js_context,
                   in nsIIDRef iid,
                   in nsISupports obj,
                   in nsIClassInfo class_info,
                   inout voidPtr policy);

    void CanCreateInstance(
                   in JSContextPtr js_context,
                   in nsCIDRef cid);

    void CanGetService(
                   in JSContextPtr js_context,
                   in nsCIDRef cid);

    void CanAccess(in PRUint32 action,
                   in nsIXPCNativeCallContext call_context,
                   in JSContextPtr js_context,
                   in JSObjectPtr js_object,
                   in nsISupports obj,
                   in nsIClassInfo class_info,
                   in jsid name,
                   inout voidPtr policy);
};



///////////////////////////////////////////////////////////////////////////////
//  nsIPrincipal
///////////////////////////////////////////////////////////////////////////////
interface nsIContentSecurityPolicy;

//[uuid(0575ea96-4561-4dc6-a818-3c4c97c2430d)]
[uuid(799ab95c-0038-4e0f-b705-74c21f185bb5)]
interface nsIPrincipal : nsISupports //nsISerializable
{
    // TODO: fill out (if necessary)
    void placeholder();
};



///////////////////////////////////////////////////////////////////////////////
//  nsIScriptSecurityManager
///////////////////////////////////////////////////////////////////////////////

interface nsIURI;
interface nsIChannel;
//[uuid(f4d74511-2b2d-4a14-a3e4-a392ac5ac3ff)]
[uuid(50eda256-4dd2-4c7c-baed-96983910af9f)]
interface nsIScriptSecurityManager : nsIXPCSecurityManager
{
    void checkPropertyAccess(
                      in JSContextPtr js_context,
                      in JSObjectPtr js_object,
                      in string class_name,
                      in jsid property,
                      in PRUint32 action);

    void checkLoadURIFromScript(
                      in JSContextPtr cx,
                      in nsIURI uri);

    void checkLoadURIWithPrincipal(
                      in nsIPrincipal principal,
                      in nsIURI uri, 
                      in unsigned long flags);

    void checkLoadURI(in nsIURI from,
                      in nsIURI uri,
                      in unsigned long flags);

    void checkLoadURIStr(
                      in AUTF8String from,
                      in AUTF8String uri,
                      in unsigned long flags);

    void checkFunctionAccess(
                      in JSContextPtr cx,
                      in voidPtr fun_obj,
                      in voidPtr target_obj);

    boolean canExecuteScripts(
                      in JSContextPtr cx,
                      in nsIPrincipal principal);

    nsIPrincipal getSubjectPrincipal();

    nsIPrincipal getSystemPrincipal();

    nsIPrincipal getCertificatePrincipal(
                      in AUTF8String cert_fingerprint,
                      in AUTF8String subject_name,
                      in AUTF8String pretty_name,
                      in nsISupports cert,
                      in nsIURI uri);
            
    nsIPrincipal getCodebasePrincipal(in nsIURI uri);

    short requestCapability(
                      in nsIPrincipal principal,
                      in string capability);

    boolean isCapabilityEnabled(in string capability);
    void enableCapability(in string capability);
    void revertCapability(in string capability);
    void disableCapability(in string capability);

    void setCanEnableCapability(
                      in AUTF8String certificate_id,
                      in string capability,
                      in short can_enable);

    nsIPrincipal getObjectPrincipal(
                      in JSContextPtr cx,
                      in JSObjectPtr obj);

    boolean subjectPrincipalIsSystem();

    void checkSameOrigin(
                      in JSContextPtr js_context,
                      in nsIURI target_uri);

    void checkSameOriginURI(
                      in nsIURI source_uri,
                      in nsIURI target_uri);

    void checkSameOriginPrincipal(
                      in nsIPrincipal source_principal,
                      in nsIPrincipal target_principal);

    nsIPrincipal getPrincipalFromContext(in JSContextPtr cx);

    boolean securityCompareURIs(
                      in nsIURI subject_uri,
                      in nsIURI object_uri);
};


%{C++
#define NS_SCRIPTSECURITYMANAGER_CONTRACTID "@mozilla.org/scriptsecuritymanager;1"
#define NS_SCRIPTSECURITYMANAGER_CLASSNAME "scriptsecuritymanager"
%}

///////////////////////////////////////////////////////////////////////////////
//  nsISSLCertErrorDialog
///////////////////////////////////////////////////////////////////////////////

[scriptable, uuid(0729ce8e-8935-4989-ba72-a2d6307f2365)]
interface nsISSLCertErrorDialog : nsISupports
{
    void showCertError(in nsIInterfaceRequestor ctx, 
                       in nsISSLStatus status,
                       in nsIX509Cert cert,
                       in AString text_error_message,
                       in AString html_error_message,
                       in ACString host_name,
                       in PRUint32 port_number);
};

%{C++
#define NS_SCRIPTSECURITYMANAGER_CONTRACTID "@mozilla.org/scriptsecuritymanager;1"
#define NS_SCRIPTSECURITYMANAGER_CLASSNAME "scriptsecuritymanager"
%}

%{ C++
class nsPresContext;
class nsIPresShell;
%}

/**
 * The nsIDocShell interface.
 */

[ptr] native nsPresContext(nsPresContext);
[ptr] native nsIPresShell(nsIPresShell);

interface nsIURI;
interface nsIChannel;
interface nsIContentViewer;
interface nsIURIContentListener;
interface nsIDOMEventTarget;
interface nsIDocShellLoadInfo;
interface nsIDocumentCharsetInfo;
interface nsIWebNavigation;
interface nsISimpleEnumerator;
interface nsIInputStream;
interface nsIRequest;
interface nsISHEntry;
interface nsILayoutHistoryState;
interface nsISecureBrowserUI;
interface nsIDOMStorage;
interface nsIPrincipal;
interface nsIWebBrowserPrint;
interface nsIVariant;
[scriptable, uuid(98cdbcc4-2d81-4191-a63f-b6c52085edbc)]
interface nsIDocShell : nsISupports
{
  /**
   * Loads a given URI.  This will give priority to loading the requested URI
   * in the object implementing this interface.  If it can't be loaded here
   * however, the URL dispatcher will go through its normal process of content
   * loading.
   *
   * @param uri        - The URI to load.
   * @param loadInfo   - This is the extended load info for this load.  This
   *                     most often will be null, but if you need to do
   *                     additional setup for this load you can get a loadInfo
   *                     object by calling createLoadInfo.  Once you have this
   *                     object you can set the needed properties on it and
   *                     then pass it to loadURI.
   * @param aLoadFlags - Flags to modify load behaviour. Flags are defined in
   *                     nsIWebNavigation.  Note that using flags outside
   *                     LOAD_FLAGS_MASK is only allowed if passing in a
   *                     non-null loadInfo.  And even some of those might not
   *                     be allowed.  Use at your own risk.
   */
  [noscript]void loadURI(in nsIURI uri,
                         in nsIDocShellLoadInfo loadInfo,
                         in unsigned long aLoadFlags,
                         in boolean firstParty);

  /**
   * Loads a given stream. This will give priority to loading the requested
   * stream in the object implementing this interface. If it can't be loaded
   * here however, the URL dispatched will go through its normal process of
   * content loading.
   *
   * @param aStream         - The input stream that provides access to the data
   *                          to be loaded.  This must be a blocking, threadsafe
   *                          stream implementation.
   * @param aURI            - The URI representing the stream, or null.
   * @param aContentType    - The type (MIME) of data being loaded (empty if unknown).
   * @param aContentCharset - The charset of the data being loaded (empty if unknown).
   * @param aLoadInfo       - This is the extended load info for this load.  This
   *                          most often will be null, but if you need to do
   *                          additional setup for this load you can get a
   *                          loadInfo object by calling createLoadInfo.  Once
   *                          you have this object you can set the needed
   *                          properties on it and then pass it to loadStream.
   */
  [noscript]void loadStream(in nsIInputStream aStream,
                            in nsIURI aURI,
                            in ACString aContentType,
                            in ACString aContentCharset,
                            in nsIDocShellLoadInfo aLoadInfo);

 const long INTERNAL_LOAD_FLAGS_NONE                    = 0x0;
  const long INTERNAL_LOAD_FLAGS_INHERIT_OWNER           = 0x1;
  const long INTERNAL_LOAD_FLAGS_DONT_SEND_REFERRER      = 0x2;
  const long INTERNAL_LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP = 0x4;

  // This flag marks the first load in this object
  // @see nsIWebNavigation::LOAD_FLAGS_FIRST_LOAD
  const long INTERNAL_LOAD_FLAGS_FIRST_LOAD              = 0x8;

  const long INTERNAL_LOAD_FLAGS_BYPASS_CLASSIFIER       = 0x10;
  const long INTERNAL_LOAD_FLAGS_FORCE_ALLOW_COOKIES     = 0x20;

  /**
   * Loads the given URI.  This method is identical to loadURI(...) except
   * that its parameter list is broken out instead of being packaged inside
   * of an nsIDocShellLoadInfo object...
   *
   * @param aURI            - The URI to load.
   * @param aReferrer       - Referring URI
   * @param aOwner          - Owner (security principal)
   * @param aInheritOwner   - Flag indicating whether the owner of the current
   *                          document should be inherited if aOwner is null.
   * @param aStopActiveDoc  - Flag indicating whether loading the current
   *                          document should be stopped.
   * @param aWindowTarget   - Window target for the load.
   * @param aTypeHint       - A hint as to the content-type of the resulting
   *                          data.  May be null or empty if no hint.
   * @param aPostDataStream - Post data stream (if POSTing)
   * @param aHeadersStream  - Stream containing "extra" request headers...
   * @param aLoadFlags      - Flags to modify load behaviour. Flags are defined
   *                          in nsIWebNavigation.
   * @param aSHEntry        - Active Session History entry (if loading from SH)
   */
  [noscript]void internalLoad(in nsIURI aURI,
                              in nsIURI aReferrer,
                              in nsISupports aOwner,
                              in PRUint32 aFlags,
                              in wstring aWindowTarget,
                              in string aTypeHint,
                              in nsIInputStream aPostDataStream,
                              in nsIInputStream aHeadersStream,
                              in unsigned long aLoadFlags,
                              in nsISHEntry aSHEntry,
                              in boolean firstParty,
                              out nsIDocShell aDocShell,
                              out nsIRequest aRequest);

  /**
   * Do either a history.pushState() or history.replaceState() operation,
   * depending on the value of aReplace.
   */
  void addState(in nsIVariant aData, in DOMString aTitle,
                in DOMString aURL, in boolean aReplace);
  /**
   * Creates a DocShellLoadInfo object that you can manipulate and then pass
   * to loadURI.
   */
  void createLoadInfo(out nsIDocShellLoadInfo loadInfo);

  /**
   * Reset state to a new content model within the current document and the document
   * viewer.  Called by the document before initiating an out of band document.write().
   */
  void prepareForNewContentModel();

  /**
   * For editors and suchlike who wish to change the URI associated with the
   * document. Note if you want to get the current URI, use the read-only
   * property on nsIWebNavigation.
   */
  void setCurrentURI(in nsIURI aURI);

  /**
   * Notify the associated content viewer and all child docshells that they are
   * about to be hidden.  If |isUnload| is true, then the document is being
   * unloaded as well.
   *
   * @param isUnload if true, fire the unload event in addition to the pagehide
   *                 event.
   */
  [noscript] void firePageHideNotification(in boolean isUnload);

  /**
   * Presentation context for the currently loaded document.  This may be null.
   */
  [noscript] readonly attribute nsPresContext presContext;

  /**
   * Presentation shell for the currently loaded document.  This may be null.
   */
  [noscript] readonly attribute nsIPresShell presShell;

  /**
   * Presentation shell for the oldest document, if this docshell is
   * currently transitioning between documents.
   */
  [noscript] readonly attribute nsIPresShell eldestPresShell;

  /**
   * Content Viewer that is currently loaded for this DocShell.  This may
   * change as the underlying content changes.
   */
  readonly attribute nsIContentViewer contentViewer;

  /**
   * This attribute allows chrome to tie in to handle DOM events that may
   * be of interest to chrome.
   */
  attribute nsIDOMEventTarget chromeEventHandler;
  /**
   * The document charset info.  This is used by a load to determine priorities
   * for charset detection etc.
   */
  attribute nsIDocumentCharsetInfo documentCharsetInfo;

  /**
   * Whether to allow plugin execution
   */
  attribute boolean allowPlugins;

  /**
   * Whether to allow Javascript execution
   */
  attribute boolean allowJavascript;

  /**
   * Attribute stating if refresh based redirects can be allowed
   */
  attribute  boolean allowMetaRedirects;

  /**
   * Attribute stating if it should allow subframes (framesets/iframes) or not
   */
  attribute boolean allowSubframes;

  /**
   * Attribute stating whether or not images should be loaded.
   */
  attribute boolean allowImages;

  /**
   * Attribute that determines whether DNS prefetch is allowed for this subtree
   * of the docshell tree.  Defaults to true.  Setting this will make it take
   * effect starting with the next document loaded in the docshell.
   */
  attribute boolean allowDNSPrefetch;

  /**
   * Get an enumerator over this docShell and its children.
   *
   * @param aItemType  - Only include docShells of this type, or if typeAll,
   *                     include all child shells.
   *                     Uses types from nsIDocShellTreeItem.
   * @param aDirection - Whether to enumerate forwards or backwards.
   */

  const long ENUMERATE_FORWARDS  = 0;
  const long ENUMERATE_BACKWARDS = 1;

  nsISimpleEnumerator getDocShellEnumerator(in long aItemType,
                                            in long aDirection);

  /**
   * The type of application that created this window
   */
  const unsigned long APP_TYPE_UNKNOWN  = 0;
  const unsigned long APP_TYPE_MAIL     = 1;
  const unsigned long APP_TYPE_EDITOR   = 2;

  attribute unsigned long appType;

  /**
   * certain dochshells (like the message pane)
   * should not throw up auth dialogs
   * because it can act as a password trojan
   */
  attribute boolean allowAuth;

  /**
   * Set/Get the document scale factor.  When setting this attribute, a
   * NS_ERROR_NOT_IMPLEMENTED error may be returned by implementations
   * not supporting zoom.  Implementations not supporting zoom should return
   * 1.0 all the time for the Get operation.  1.0 by the way is the default
   * of zoom.  This means 100% of normal scaling or in other words normal size
   * no zoom.
   */
  attribute float zoom;

  /*
   * The size, in CSS pixels, of the horizontal margins for the <body> of an
   * HTML document in this docshel; used to implement the marginwidth attribute
   * on HTML <frame>/<iframe> elements.  A value smaller than zero indicates
   * that the attribute was not set.
   */
  attribute long marginWidth;

  /*
   * The size, in CSS pixels, of the vertical margins for the <body> of an HTML
   * document in this docshel; used to implement the marginheight attribute on
   * HTML <frame>/<iframe> elements.  A value smaller than zero indicates that
   * the attribute was not set.
   */
  attribute long marginHeight;

  /*
   * Tells the docshell to offer focus to its tree owner.
   * This is currently only necessary for embedding chrome.
   */
  void tabToTreeOwner(in boolean forward,
                      out boolean tookFocus);

  /**
   * Current busy state for DocShell
   */
  const unsigned long BUSY_FLAGS_NONE             = 0;
  const unsigned long BUSY_FLAGS_BUSY             = 1;
  const unsigned long BUSY_FLAGS_BEFORE_PAGE_LOAD = 2;
  const unsigned long BUSY_FLAGS_PAGE_LOADING     = 4;

  /**
   * Load commands for the document
   */
  const unsigned long LOAD_CMD_NORMAL  = 0x1;   // Normal load
  const unsigned long LOAD_CMD_RELOAD  = 0x2;   // Reload
  const unsigned long LOAD_CMD_HISTORY = 0x4;   // Load from history
  const unsigned long LOAD_CMD_PUSHSTATE = 0x8; // History.pushState()

  readonly attribute unsigned long busyFlags;

  /*
   * attribute to access the loadtype  for the document
   */
  attribute unsigned long  loadType;

  /*
   * returns true if the docshell is being destroyed, false otherwise
   */
  boolean isBeingDestroyed();

  /*
   * Returns true if the docshell is currently executing the onLoad Handler
   */
  readonly attribute boolean isExecutingOnLoadHandler;

  attribute nsILayoutHistoryState layoutHistoryState;

  readonly attribute boolean shouldSaveLayoutState;

  /**
   * The SecureBrowserUI object for this docshell.  This is set by XUL
   * <browser> or nsWebBrowser for their root docshell.
   */
  attribute nsISecureBrowserUI securityUI;

  /**
   * Cancel the XPCOM timers for each meta-refresh URI in this docshell,
   * and this docshell's children, recursively. The meta-refresh timers can be
   * restarted using resumeRefreshURIs().  If the timers are already suspended,
   * this has no effect.
   */
  void suspendRefreshURIs();

  /**
   * Restart the XPCOM timers for each meta-refresh URI in this docshell,
   * and this docshell's children, recursively.  If the timers are already
   * running, this has no effect.
   */
  void resumeRefreshURIs();
 /**
   * Begin firing WebProgressListener notifications for restoring a page
   * presentation. |viewer| is the content viewer whose document we are
   * starting to load.  If null, it defaults to the docshell's current content
   * viewer, creating one if necessary.  |top| should be true for the toplevel
   * docshell that is being restored; it will be set to false when this method
   * is called for child docshells.  This method will post an event to
   * complete the simulated load after returning to the event loop.
   */
  void beginRestore(in nsIContentViewer viewer, in boolean top);

  /**
   * Finish firing WebProgressListener notifications and DOM events for
   * restoring a page presentation.  This should only be called via
   * beginRestore().
   */
  void finishRestore();

  /* Track whether we're currently restoring a document presentation. */
  readonly attribute boolean restoringDocument;

  /* attribute to access whether error pages are enabled */
  attribute boolean useErrorPages;

  /**
   * Keeps track of the previous SHTransaction index and the current
   * SHTransaction index at the time that the doc shell begins to load.
   * Used for ContentViewer eviction.
   */
  readonly attribute long previousTransIndex;
  readonly attribute long loadedTransIndex;

  /**
   * Notification that entries have been removed from the beginning of a
   * nsSHistory which has this as its rootDocShell.
   *
   * @param numEntries - The number of entries removed
   */
  void historyPurged(in long numEntries);

  /*
   * Retrieves the WebApps session storage object for the supplied domain.
   * If it doesn't already exist, a new one will be created.
   *
   * @param uri the uri of the storage object to retrieve
   * @param documentURI new storage will be created with reference to this
   *                    document.documentURI that will appear in storage event
   */
  nsIDOMStorage getSessionStorageForURI(in nsIURI uri,
                                        in DOMString documentURI);
  /*
   * Retrieves the WebApps session storage object for the supplied principal.
   *
   * @param principal returns a storage for this principal
   * @param documentURI new storage will be created with reference to this
   *                    document.documentURI that will appear in storage event
   * @param create If true and a session storage object doesn't
   *               already exist, a new one will be created.
   */
  nsIDOMStorage getSessionStorageForPrincipal(in nsIPrincipal principal,
                                              in DOMString documentURI,
                                              in boolean create);

  /*
   * Add a WebApps session storage object to the docshell.
   *
   * @param principal the principal the storage object is associated with
   * @param storage the storage object to add
   */
  void addSessionStorage(in nsIPrincipal principal, in nsIDOMStorage storage);

  /**
   * Gets the channel for the currently loaded document, if any.
   * For a new document load, this will be the channel of the previous document
   * until after OnLocationChange fires.
   */
  readonly attribute nsIChannel currentDocumentChannel;

  /**
   * Set the offset of this child in its container.
   */
  [noscript] void setChildOffset(in unsigned long offset);

  /**
   * Find out whether the docshell is currently in the middle of a page
   * transition. This is set just before the pagehide/unload events fire.
   */
  readonly attribute boolean isInUnload;

  /**
   * Find out if the currently loaded document came from a suspicious channel
   * (such as a JAR channel where the server-returned content type isn't a
   * known JAR type).
   */
  readonly attribute boolean channelIsUnsafe;
  /**
   * Disconnects this docshell's editor from its window, and stores the
   * editor data in the open document's session history entry.  This
   * should be called only during page transitions.
   */
  [noscript, notxpcom] void DetachEditorFromWindow();

  /**
   * If true, this browser is not visible in the traditional sense, but
   * is actively being rendered to the screen (ex. painted on a canvas)
   * and should be treated accordingly.
   **/
  attribute boolean isOffScreenBrowser;

  /**
   * If the current content viewer isn't initialized for print preview,
   * it is replaced with one which is and to which an about:blank document
   * is loaded.
   */
  readonly attribute nsIWebBrowserPrint printPreview;

  /**
   * Whether this docshell can execute scripts based on its hierarchy.
   * The rule of thumb here is that we disable js if this docshell or any
   * of its parents disallow scripting, unless the only reason for js being
   * disabled in this docshell is a parent docshell having a document that
   * is in design mode.  In that case, we explicitly allow scripting on the
   * current docshell.
   */
  readonly attribute boolean canExecuteScripts;

  /**
   * Sets whether a docshell is active. An active docshell is one that is
   * visible, and thus is not a good candidate for certain optimizations
   * like image frame discarding. Docshells are active unless told otherwise.
   */
  attribute boolean isActive;

  /**
   * The ID of the docshell in the session history.
   */
  readonly attribute unsigned long long historyID;

  /**
   * Sets whether a docshell is an app tab. An app tab docshell may behave
   * differently than a non-app tab docshell in some cases, such as when
   * handling link clicks. Docshells are not app tabs unless told otherwise.
   */
  attribute boolean isAppTab;
};

[uuid(5f7a2184-31b6-4d67-9c75-0c17477766e2)]
interface nsIDocShell_MOZILLA_2_0_BRANCH : nsISupports {
  /**
   * Create a new about:blank document and content viewer.
   * @param aPrincipal the principal to use for the new document.
   */
  void createAboutBlankContentViewer(in nsIPrincipal aPrincipal);
};

